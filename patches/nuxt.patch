diff --git a/README.md b/README.md
index f96ad2e925c3bb1faa6728f76cca975c73ae40a9..904177e9276afcd1bcf0e8fd4ce28ee7716d4a3f 100644
--- a/README.md
+++ b/README.md
@@ -60,7 +60,7 @@ Example of an `app.vue`:
 <script setup lang="ts">
 useSeoMeta({
   title: 'Meet Nuxt',
-  description: 'The Intuitive Vue Framework.',
+  description: 'The Intuitive Vue Framework.'
 })
 </script>
 
@@ -93,13 +93,13 @@ Discover our [list of modules](https://nuxt.com/modules) to supercharge your Nux
 We invite you to contribute and help improve Nuxt üíö
 
 Here are a few ways you can get involved:
-- **Reporting Bugs:** If you come across any bugs or issues, please check out the [reporting bugs guide](https://nuxt.com/docs/4.x/community/reporting-bugs) to learn how to submit a bug report.
-- **Suggestions:** Have ideas to enhance Nuxt? We'd love to hear them! Check out the [contribution guide](https://nuxt.com/docs/4.x/community/contribution) to share your suggestions.
-- **Questions:** If you have questions or need assistance, the [getting help guide](https://nuxt.com/docs/4.x/community/getting-help) provides resources to help you out.
+- **Reporting Bugs:** If you come across any bugs or issues, please check out the [reporting bugs guide](https://nuxt.com/docs/community/reporting-bugs) to learn how to submit a bug report.
+- **Suggestions:** Have ideas to enhance Nuxt? We'd love to hear them! Check out the [contribution guide](https://nuxt.com/docs/community/contribution) to share your suggestions.
+- **Questions:** If you have questions or need assistance, the [getting help guide](https://nuxt.com/docs/community/getting-help) provides resources to help you out.
 
 ## <a name="local-development">üè† Local Development</a>
 
-Follow the docs to [Set Up Your Local Development Environment](https://nuxt.com/docs/4.x/community/framework-contribution#setup) to contribute to the framework and documentation.
+Follow the docs to [Set Up Your Local Development Environment](https://nuxt.com/docs/community/framework-contribution#setup) to contribute to the framework and documentation.
 
 ## <a name="professional-support">üõü Professional Support</a>
 
diff --git a/dist/app/components/client-only.d.ts b/dist/app/components/client-only.d.ts
index 57cc2c294e911310f97b73ee4a788d692653890a..67897283994572f9335730fd359c60a0bd353a88 100644
--- a/dist/app/components/client-only.d.ts
+++ b/dist/app/components/client-only.d.ts
@@ -1,13 +1,13 @@
-import type { ComponentOptions, InjectionKey, SlotsType, VNode } from 'vue';
+import type { ComponentOptions, InjectionKey, RendererNode, SlotsType, VNode } from 'vue';
 export declare const clientOnlySymbol: InjectionKey<boolean>;
 declare const _default: import("vue").DefineComponent<{
     placeholder?: any;
     fallback?: any;
     placeholderTag?: any;
     fallbackTag?: any;
-}, () => VNode<import("vue").RendererNode, import("vue").RendererElement, {
+}, () => VNode<RendererNode, import("vue").RendererElement, {
     [key: string]: any;
-}> | VNode<import("vue").RendererNode, import("vue").RendererElement, {
+}> | VNode<RendererNode, import("vue").RendererElement, {
     [key: string]: any;
 }>[] | undefined, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<{
     placeholder?: any;
@@ -24,3 +24,5 @@ declare const _default: import("vue").DefineComponent<{
 }>, {}, {}, string, import("vue").ComponentProvideOptions, true, {}, any>;
 export default _default;
 export declare function createClientOnly<T extends ComponentOptions>(component: T): any;
+export declare function isStartFragment(element: RendererNode): boolean;
+export declare function isEndFragment(element: RendererNode): boolean;
diff --git a/dist/app/components/client-only.js b/dist/app/components/client-only.js
index 19e76ad081b5ffe8aaa9cd073f8e8bab95d9ddeb..54a2141a77d02017ba8b8a562e2abcc4fb154bf0 100644
--- a/dist/app/components/client-only.js
+++ b/dist/app/components/client-only.js
@@ -1,8 +1,8 @@
-import { cloneVNode, createElementBlock, defineComponent, getCurrentInstance, h, onMounted, provide, shallowRef } from "vue";
+import { cloneVNode, createElementBlock, createStaticVNode, defineComponent, getCurrentInstance, h, onMounted, provide, shallowRef } from "vue";
 import { isPromise } from "@vue/shared";
 import { useNuxtApp } from "../nuxt.js";
 import ServerPlaceholder from "./server-placeholder.js";
-import { elToStaticVNode } from "./utils.js";
+import { getFragmentHTML } from "./utils.js";
 export const clientOnlySymbol = Symbol.for("nuxt:client-only");
 const STATIC_DIV = "<div></div>";
 export default defineComponent({
@@ -128,3 +128,16 @@ function extractDirectives(instance) {
   instance.vnode.dirs = null;
   return directives;
 }
+function elToStaticVNode(el, staticNodeFallback) {
+  const fragment = el ? getFragmentHTML(el) : staticNodeFallback ? [staticNodeFallback] : void 0;
+  if (fragment) {
+    return createStaticVNode(fragment.join(""), fragment.length);
+  }
+  return h("div");
+}
+export function isStartFragment(element) {
+  return element.nodeName === "#comment" && element.nodeValue === "[";
+}
+export function isEndFragment(element) {
+  return element.nodeName === "#comment" && element.nodeValue === "]";
+}
diff --git a/dist/app/components/island-renderer.d.ts b/dist/app/components/island-renderer.d.ts
deleted file mode 100644
index 33ebee4e499af20ebae33ab7489f144ca7f9253a..0000000000000000000000000000000000000000
diff --git a/dist/app/components/island-renderer.js b/dist/app/components/island-renderer.js
deleted file mode 100644
index 29d6a08a9f611f63a14a420ff1445b70a45379d4..0000000000000000000000000000000000000000
diff --git a/dist/app/components/nuxt-error-page.vue b/dist/app/components/nuxt-error-page.vue
index 97a60e1a9bce9f6e7ea22b46ee8df7da9973a9aa..aec6d221e1d29526ebf243a62fdace665b3cd693 100644
--- a/dist/app/components/nuxt-error-page.vue
+++ b/dist/app/components/nuxt-error-page.vue
@@ -21,6 +21,6 @@ const statusMessage = _error.statusMessage ?? (is404 ? "Page Not Found" : "Inter
 const description = _error.message || _error.toString();
 const stack = import.meta.dev && !is404 ? _error.description || `<pre>${stacktrace}</pre>` : void 0;
 const _Error404 = defineAsyncComponent(() => import("./error-404.vue"));
-const _Error = import.meta.dev ? defineAsyncComponent(() => import("./error-dev.vue")) : defineAsyncComponent(() => import("./error-500.vue"));
+const _Error = defineAsyncComponent(() => import("./error-500.vue"));
 const ErrorTemplate = is404 ? _Error404 : _Error;
 </script>
diff --git a/dist/app/components/nuxt-island.d.ts b/dist/app/components/nuxt-island.d.ts
index 7fb9a5fe489c1a03f8bfeccb6574628302905c1b..40ffe00c2af77b60f831ee89591e57b2e038962a 100644
--- a/dist/app/components/nuxt-island.d.ts
+++ b/dist/app/components/nuxt-island.d.ts
@@ -1,4 +1,4 @@
-import type { PropType, RendererNode, VNode } from 'vue';
+import type { PropType } from 'vue';
 declare const _default: import("vue").DefineComponent<import("vue").ExtractPropTypes<{
     name: {
         type: StringConstructor;
@@ -25,13 +25,7 @@ declare const _default: import("vue").DefineComponent<import("vue").ExtractPropT
         type: BooleanConstructor;
         default: boolean;
     };
-}>, (_ctx: any, _cache: any) => (VNode<RendererNode, import("vue").RendererElement, {
-    [key: string]: any;
-}> | VNode<RendererNode, import("vue").RendererElement, {
-    [key: string]: any;
-}>[])[] | VNode<any, any, {
-    [key: string]: any;
-}>[], {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, "error"[], "error", import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<{
+}>, () => any, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, "error"[], "error", import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<{
     name: {
         type: StringConstructor;
         required: true;
diff --git a/dist/app/components/nuxt-island.js b/dist/app/components/nuxt-island.js
index a4c4faf4b3e28a6920ed7b934a191e4fc193d577..9ebf6bcb32f58fd8aa9bbf0b932665deccf2b94f 100644
--- a/dist/app/components/nuxt-island.js
+++ b/dist/app/components/nuxt-island.js
@@ -1,43 +1,31 @@
-import { Fragment, Teleport, computed, createStaticVNode, createVNode, defineComponent, getCurrentInstance, h, nextTick, onBeforeUnmount, onMounted, ref, shallowRef, toRaw, watch, withMemo } from "vue";
+import { computed, defineComponent, getCurrentInstance, onBeforeUnmount, onMounted, ref, shallowRef, useId, watch } from "vue";
 import { debounce } from "perfect-debounce";
 import { hash } from "ohash";
 import { appendResponseHeader } from "h3";
 import { randomUUID } from "uncrypto";
 import { joinURL, withQuery } from "ufo";
+import { renderOnigiri } from "vue-onigiri/runtime/deserialize";
+import { join } from "pathe";
 import { useNuxtApp, useRuntimeConfig } from "../nuxt.js";
 import { createError } from "../composables/error.js";
 import { prerenderRoutes, useRequestEvent } from "../composables/ssr.js";
 import { injectHead } from "../composables/head.js";
-import { getFragmentHTML, isEndFragment, isStartFragment } from "./utils.js";
-import { appBaseURL, remoteComponentIslands, selectiveClient } from "#build/nuxt.config.mjs";
+import { remoteComponentIslands } from "#build/nuxt.config.mjs";
+const viteFetch = import.meta.server ? import.meta.dev ? (src, exportName) => import("#build/dist/server/server.mjs").then((r) => r.executeFile(src)).then((r) => {
+  return r[exportName];
+}) : (
+  // todo path association between server and client chunks
+  ((src, exportName) => import("virtual:vue-onigiri").then((r) => {
+    console.log(src, exportName);
+    return r.default.get(src + "__" + exportName);
+  }))
+) : (src) => import(
+  /* @vite-ignore */
+  join(src.replace("/app", ""))
+).then((r) => r.default || r);
 const pKey = "_islandPromises";
-const SSR_UID_RE = /data-island-uid="([^"]*)"/;
-const DATA_ISLAND_UID_RE = /data-island-uid(="")?(?!="[^"])/g;
-const SLOTNAME_RE = /data-island-slot="([^"]*)"/g;
-const SLOT_FALLBACK_RE = / data-island-slot="([^"]*)"[^>]*>/g;
-const ISLAND_SCOPE_ID_RE = /^<[^> ]*/;
 let id = 1;
 const getId = import.meta.client ? () => (id++).toString() : randomUUID;
-const components = import.meta.client ? /* @__PURE__ */ new Map() : void 0;
-async function loadComponents(source = appBaseURL, paths) {
-  if (!paths) {
-    return;
-  }
-  const promises = [];
-  for (const [component, item] of Object.entries(paths)) {
-    if (!components.has(component)) {
-      promises.push((async () => {
-        const chunkSource = joinURL(source, item.chunk);
-        const c = await import(
-          /* @vite-ignore */
-          chunkSource
-        ).then((m) => m.default || m);
-        components.set(component, c);
-      })());
-    }
-  }
-  await Promise.all(promises);
-}
 export default defineComponent({
   name: "NuxtIsland",
   inheritAttrs: false,
@@ -69,18 +57,16 @@ export default defineComponent({
     }
   },
   emits: ["error"],
-  async setup(props, { slots, expose, emit }) {
-    let canTeleport = import.meta.server;
-    const teleportKey = shallowRef(0);
-    const key = shallowRef(0);
-    const canLoadClientComponent = computed(() => selectiveClient && (props.dangerouslyLoadClientComponents || !props.source));
+  async setup(props, { expose, emit }) {
+    const teleportKey = ref(0);
     const error = ref(null);
     const config = useRuntimeConfig();
     const nuxtApp = useNuxtApp();
-    const filteredProps = computed(() => props.props ? Object.fromEntries(Object.entries(props.props).filter(([key2]) => !key2.startsWith("data-v-"))) : {});
+    const filteredProps = computed(() => props.props ? Object.fromEntries(Object.entries(props.props).filter(([key]) => !key.startsWith("data-v-"))) : {});
     const hashId = computed(() => hash([props.name, filteredProps.value, props.context, props.source]).replace(/[-_]/g, ""));
     const instance = getCurrentInstance();
     const event = useRequestEvent();
+    const ast = ref(nuxtApp.payload.data[`${props.name}_${hashId.value}`]?.ast);
     let activeHead;
     const eventFetch = import.meta.server ? event.fetch : globalThis.fetch;
     const mounted = shallowRef(false);
@@ -93,100 +79,31 @@ export default defineComponent({
         activeHead.dispose();
       }
     });
-    function setPayload(key2, result) {
+    function setPayload(key, result) {
       const toRevive = {};
-      if (result.props) {
-        toRevive.props = result.props;
-      }
-      if (result.slots) {
-        toRevive.slots = result.slots;
-      }
-      if (result.components) {
-        toRevive.components = result.components;
-      }
       if (result.head) {
         toRevive.head = result.head;
       }
-      nuxtApp.payload.data[key2] = {
+      if (result.ast) {
+        toRevive.ast = result.ast;
+      }
+      nuxtApp.payload.data[key] = {
         __nuxt_island: {
-          key: key2,
+          key,
           ...import.meta.server && import.meta.prerender ? {} : { params: { ...props.context, props: props.props ? JSON.stringify(props.props) : void 0 } },
           result: toRevive
         },
         ...result
       };
     }
-    const payloads = {};
-    if (instance.vnode.el) {
-      const slots2 = toRaw(nuxtApp.payload.data[`${props.name}_${hashId.value}`])?.slots;
-      if (slots2) {
-        payloads.slots = slots2;
-      }
-      if (selectiveClient) {
-        const components2 = toRaw(nuxtApp.payload.data[`${props.name}_${hashId.value}`])?.components;
-        if (components2) {
-          payloads.components = components2;
-        }
-      }
-    }
-    const ssrHTML = ref("");
-    if (import.meta.client && instance.vnode?.el) {
-      if (import.meta.dev) {
-        let currentEl = instance.vnode.el;
-        let startEl = null;
-        let isFirstElement = true;
-        while (currentEl) {
-          if (isEndFragment(currentEl)) {
-            if (startEl !== currentEl.previousSibling) {
-              console.warn(`[\`Server components(and islands)\`] "${props.name}" must have a single root element. (HTML comments are considered elements as well.)`);
-            }
-            break;
-          } else if (!isStartFragment(currentEl) && isFirstElement) {
-            isFirstElement = false;
-            if (currentEl.nodeType === 1) {
-              startEl = currentEl;
-            }
-          }
-          currentEl = currentEl.nextSibling;
-        }
-      }
-      ssrHTML.value = getFragmentHTML(instance.vnode.el, true)?.join("") || "";
-      const key2 = `${props.name}_${hashId.value}`;
-      nuxtApp.payload.data[key2] ||= {};
-      nuxtApp.payload.data[key2].html = ssrHTML.value.replaceAll(new RegExp(`data-island-uid="${ssrHTML.value.match(SSR_UID_RE)?.[1] || ""}"`, "g"), `data-island-uid=""`);
-    }
-    const uid = ref(ssrHTML.value.match(SSR_UID_RE)?.[1] || getId());
-    const currentSlots = new Set(Object.keys(slots));
-    const availableSlots = computed(() => new Set([...ssrHTML.value.matchAll(SLOTNAME_RE)].map((m) => m[1])));
-    const html = computed(() => {
-      let html2 = ssrHTML.value;
-      if (props.scopeId) {
-        html2 = html2.replace(ISLAND_SCOPE_ID_RE, (full) => full + " " + props.scopeId);
-      }
-      if (import.meta.client && !canLoadClientComponent.value) {
-        for (const [key2, value] of Object.entries(payloads.components || {})) {
-          html2 = html2.replace(new RegExp(` data-island-uid="${uid.value}" data-island-component="${key2}"[^>]*>`), (full) => {
-            return full + value.html;
-          });
-        }
-      }
-      if (payloads.slots) {
-        return html2.replaceAll(SLOT_FALLBACK_RE, (full, slotName) => {
-          if (!currentSlots.has(slotName)) {
-            return full + (payloads.slots?.[slotName]?.fallback || "");
-          }
-          return full;
-        });
-      }
-      return html2;
-    });
+    const uid = ref(useId() || getId());
     const head = injectHead();
     async function _fetchComponent(force = false) {
-      const key2 = `${props.name}_${hashId.value}`;
-      if (!force && nuxtApp.payload.data[key2]?.html) {
-        return nuxtApp.payload.data[key2];
+      const key = `${props.name}_${hashId.value}`;
+      if (!force && nuxtApp.payload.data[key]?.html) {
+        return nuxtApp.payload.data[key];
       }
-      const url = remoteComponentIslands && props.source ? joinURL(props.source, `/__nuxt_island/${key2}.json`) : `/__nuxt_island/${key2}.json`;
+      const url = remoteComponentIslands && props.source ? joinURL(props.source, `/__nuxt_island/${key}.json`) : `/__nuxt_island/${key}.json`;
       if (import.meta.server && import.meta.prerender) {
         nuxtApp.runWithContext(() => prerenderRoutes(url));
       }
@@ -205,7 +122,7 @@ export default defineComponent({
             appendResponseHeader(event, "x-nitro-prerender", hints);
           }
         }
-        setPayload(key2, result);
+        setPayload(key, result);
         return result;
       } catch (e) {
         if (r.status !== 200) {
@@ -221,16 +138,10 @@ export default defineComponent({
       });
       try {
         const res = await nuxtApp[pKey][uid.value];
-        ssrHTML.value = res.html.replaceAll(DATA_ISLAND_UID_RE, `data-island-uid="${uid.value}"`);
-        key.value++;
-        error.value = null;
-        payloads.slots = res.slots || {};
-        payloads.components = res.components || {};
-        if (selectiveClient && import.meta.client) {
-          if (canLoadClientComponent.value && res.components) {
-            await loadComponents(props.source, res.components);
-          }
+        if (res.ast) {
+          ast.value = res.ast;
         }
+        error.value = null;
         if (res?.head) {
           if (activeHead) {
             activeHead.patch(res.head);
@@ -238,12 +149,6 @@ export default defineComponent({
             activeHead = head.push(res.head);
           }
         }
-        if (import.meta.client) {
-          nextTick(() => {
-            canTeleport = true;
-            teleportKey.value++;
-          });
-        }
       } catch (e) {
         error.value = e;
         emit("error", e);
@@ -264,68 +169,12 @@ export default defineComponent({
       fetchComponent();
     } else if (import.meta.server || !instance.vnode.el || !nuxtApp.payload.serverRendered) {
       await fetchComponent();
-    } else if (selectiveClient && canLoadClientComponent.value) {
-      await loadComponents(props.source, payloads.components);
     }
-    return (_ctx, _cache) => {
-      if (!html.value || error.value) {
-        return [slots.fallback?.({ error: error.value }) ?? createVNode("div")];
-      }
-      return [
-        withMemo([key.value], () => {
-          return createVNode(Fragment, { key: key.value }, [h(createStaticVNode(html.value || "<div></div>", 1))]);
-        }, _cache, 0),
-        // should away be triggered ONE tick after re-rendering the static node
-        withMemo([teleportKey.value], () => {
-          const teleports = [];
-          const isKeyOdd = teleportKey.value === 0 || !!(teleportKey.value && !(teleportKey.value % 2));
-          if (uid.value && html.value && (import.meta.server || props.lazy ? canTeleport : mounted.value || instance.vnode?.el)) {
-            for (const slot in slots) {
-              if (availableSlots.value.has(slot)) {
-                teleports.push(
-                  createVNode(
-                    Teleport,
-                    // use different selectors for even and odd teleportKey to force trigger the teleport
-                    { to: import.meta.client ? `${isKeyOdd ? "div" : ""}[data-island-uid="${uid.value}"][data-island-slot="${slot}"]` : `uid=${uid.value};slot=${slot}` },
-                    { default: () => (payloads.slots?.[slot]?.props?.length ? payloads.slots[slot].props : [{}]).map((data) => slots[slot]?.(data)) }
-                  )
-                );
-              }
-            }
-            if (selectiveClient) {
-              if (import.meta.server) {
-                if (payloads.components) {
-                  for (const [id2, info] of Object.entries(payloads.components)) {
-                    const { html: html2, slots: slots2 } = info;
-                    let replaced = html2.replaceAll("data-island-uid", `data-island-uid="${uid.value}"`);
-                    for (const slot in slots2) {
-                      replaced = replaced.replaceAll(`data-island-slot="${slot}">`, (full) => full + slots2[slot]);
-                    }
-                    teleports.push(createVNode(Teleport, { to: `uid=${uid.value};client=${id2}` }, {
-                      default: () => [createStaticVNode(replaced, 1)]
-                    }));
-                  }
-                }
-              } else if (canLoadClientComponent.value && payloads.components) {
-                for (const [id2, info] of Object.entries(payloads.components)) {
-                  const { props: props2, slots: slots2 } = info;
-                  const component = components.get(id2);
-                  const vnode = createVNode(Teleport, { to: `${isKeyOdd ? "div" : ""}[data-island-uid='${uid.value}'][data-island-component="${id2}"]` }, {
-                    default: () => {
-                      return [h(component, props2, Object.fromEntries(Object.entries(slots2 || {}).map(([k, v]) => [
-                        k,
-                        () => createStaticVNode(`<div style="display: contents" data-island-uid data-island-slot="${k}">${v}</div>`, 1)
-                      ])))];
-                    }
-                  });
-                  teleports.push(vnode);
-                }
-              }
-            }
-          }
-          return h(Fragment, teleports);
-        }, _cache, 1)
-      ];
+    return () => {
+      return renderOnigiri(
+        ast.value,
+        viteFetch
+      );
     };
   }
 });
diff --git a/dist/app/components/nuxt-link.d.ts b/dist/app/components/nuxt-link.d.ts
index 9c5704b697f769226522298f6565d8e59d12b98c..4b1dbed22b64dfb4649a2c267f52be36d2b4c0e5 100644
--- a/dist/app/components/nuxt-link.d.ts
+++ b/dist/app/components/nuxt-link.d.ts
@@ -96,6 +96,6 @@ type NuxtLinkDefaultSlotProps<CustomProp extends boolean = false> = CustomProp e
 type NuxtLinkSlots<CustomProp extends boolean = false> = {
     default?: (props: NuxtLinkDefaultSlotProps<CustomProp>) => VNode[];
 };
-export declare function defineNuxtLink(options: NuxtLinkOptions): (new <CustomProp extends boolean = false>(props: NuxtLinkProps<CustomProp> & VNodeProps & AllowedComponentProps & AnchorHTMLAttributes) => InstanceType<DefineSetupFnComponent<NuxtLinkProps<CustomProp> & VNodeProps & AllowedComponentProps & AnchorHTMLAttributes, [], SlotsType<NuxtLinkSlots<CustomProp>>>>) & Record<string, any>;
-declare const _default: (new <CustomProp extends boolean = false>(props: NuxtLinkProps<CustomProp> & VNodeProps & AllowedComponentProps & AnchorHTMLAttributes) => InstanceType<DefineSetupFnComponent<NuxtLinkProps<CustomProp> & VNodeProps & AllowedComponentProps & AnchorHTMLAttributes, [], SlotsType<NuxtLinkSlots<CustomProp>>>>) & Record<string, any>;
+export declare function defineNuxtLink(options: NuxtLinkOptions): (new <CustomProp extends boolean = false>(props: NuxtLinkProps<CustomProp> & VNodeProps & AllowedComponentProps & Omit<AnchorHTMLAttributes, keyof NuxtLinkProps<CustomProp>>) => InstanceType<DefineSetupFnComponent<NuxtLinkProps<CustomProp> & VNodeProps & AllowedComponentProps & Omit<AnchorHTMLAttributes, keyof NuxtLinkProps<CustomProp>>, [], SlotsType<NuxtLinkSlots<CustomProp>>>>) & Record<string, any>;
+declare const _default: (new <CustomProp extends boolean = false>(props: NuxtLinkProps<CustomProp> & VNodeProps & AllowedComponentProps & Omit<AnchorHTMLAttributes, keyof NuxtLinkProps<CustomProp>>) => InstanceType<DefineSetupFnComponent<NuxtLinkProps<CustomProp> & VNodeProps & AllowedComponentProps & Omit<AnchorHTMLAttributes, keyof NuxtLinkProps<CustomProp>>, [], SlotsType<NuxtLinkSlots<CustomProp>>>>) & Record<string, any>;
 export default _default;
diff --git a/dist/app/components/nuxt-root.vue b/dist/app/components/nuxt-root.vue
index 3d28794b56afa4fef5321a12cf1c8702928ccf0c..017c67866082f15c45f2b0110aed0955d670c59c 100644
--- a/dist/app/components/nuxt-root.vue
+++ b/dist/app/components/nuxt-root.vue
@@ -4,11 +4,7 @@
     <ErrorComponent
       v-else-if="error"
       :error="error"
-    />
-    <IslandRenderer
-      v-else-if="islandContext"
-      :context="islandContext"
-    />
+    /> 
     <component
       :is="SingleRenderer"
       v-else-if="SingleRenderer"
@@ -25,8 +21,6 @@ import { useRoute, useRouter } from "../composables/router";
 import { PageRouteSymbol } from "../components/injections";
 import AppComponent from "#build/app-component.mjs";
 import ErrorComponent from "#build/error-component.mjs";
-import { componentIslands } from "#build/nuxt.config.mjs";
-const IslandRenderer = import.meta.server && componentIslands ? defineAsyncComponent(() => import("./island-renderer").then((r) => r.default || r)) : () => null;
 const nuxtApp = useNuxtApp();
 const onResolve = nuxtApp.deferHydration();
 if (import.meta.client && nuxtApp.isHydrating) {
@@ -56,5 +50,4 @@ onErrorCaptured((err, target, info) => {
     return false;
   }
 });
-const islandContext = import.meta.server && nuxtApp.ssrContext.islandContext;
 </script>
diff --git a/dist/app/components/utils.d.ts b/dist/app/components/utils.d.ts
index e44c8cb70ff2d33f6708dd95c69b0f72f04878cd..1ad5b2d50159dad5c007df0258063c695ff4388d 100644
--- a/dist/app/components/utils.d.ts
+++ b/dist/app/components/utils.d.ts
@@ -1,4 +1,4 @@
-import type { RendererNode, VNode } from 'vue';
+import type { RendererNode } from 'vue';
 import type { RouteLocationNormalized } from 'vue-router';
 /**
  * Internal utility
@@ -37,12 +37,3 @@ export declare function vforToArray(source: any): any[];
  * @returns {string[]|undefined} An array of string which represent the content of each element. Use `.join('')` to retrieve a component vnode.el HTML
  */
 export declare function getFragmentHTML(element: RendererNode | null, withoutSlots?: boolean): string[] | undefined;
-/**
- * Return a static vnode from an element
- * Default to a div if the element is not found and if a fallback is not provided
- * @param el renderer node retrieved from the component internal instance
- * @param staticNodeFallback fallback string to use if the element is not found. Must be a valid HTML string
- */
-export declare function elToStaticVNode(el: RendererNode | null, staticNodeFallback?: string): VNode;
-export declare function isStartFragment(element: RendererNode): boolean;
-export declare function isEndFragment(element: RendererNode): boolean;
diff --git a/dist/app/components/utils.js b/dist/app/components/utils.js
index a1404a6721fb288b4a85697eb0133f39c7ff18ec..904ed639017596b5e3315d9bc90d7d3218fa5083 100644
--- a/dist/app/components/utils.js
+++ b/dist/app/components/utils.js
@@ -1,4 +1,4 @@
-import { Transition, createStaticVNode, h } from "vue";
+import { Transition, h } from "vue";
 import { isString, isPromise, isArray, isObject } from "@vue/shared";
 import { START_LOCATION } from "#build/pages";
 export const _wrapInTransition = (props, children) => {
@@ -111,16 +111,3 @@ function getFragmentChildren(element, blocks = [], withoutSlots = false) {
   }
   return blocks;
 }
-export function elToStaticVNode(el, staticNodeFallback) {
-  const fragment = el ? getFragmentHTML(el) : staticNodeFallback ? [staticNodeFallback] : void 0;
-  if (fragment) {
-    return createStaticVNode(fragment.join(""), fragment.length);
-  }
-  return h("div");
-}
-export function isStartFragment(element) {
-  return element.nodeName === "#comment" && element.nodeValue === "[";
-}
-export function isEndFragment(element) {
-  return element.nodeName === "#comment" && element.nodeValue === "]";
-}
diff --git a/dist/app/composables/asyncData.d.ts b/dist/app/composables/asyncData.d.ts
index 2ce396cf508b44243bf3150fb2dcc7a86a4fbd9a..d3cfba8ebf9fcfb4b1d154e514e2a6f0c25e473b 100644
--- a/dist/app/composables/asyncData.d.ts
+++ b/dist/app/composables/asyncData.d.ts
@@ -3,6 +3,9 @@ import type { NuxtApp } from '../nuxt.js';
 import type { NuxtError } from './error.js';
 export type AsyncDataRequestStatus = 'idle' | 'pending' | 'success' | 'error';
 export type _Transform<Input = any, Output = any> = (input: Input) => Output | Promise<Output>;
+export type AsyncDataHandler<ResT> = (nuxtApp: NuxtApp, options: {
+    signal: AbortSignal;
+}) => Promise<ResT>;
 export type PickFrom<T, K extends Array<string>> = T extends Array<any> ? T : T extends Record<string, any> ? keyof T extends K[number] ? T : K[number] extends never ? T : Pick<T, K[number]> : T;
 export type KeysOf<T> = Array<T extends T ? keyof T extends string ? keyof T : never : never>;
 export type KeyOfRes<Transform extends _Transform> = KeysOf<ReturnType<Transform>>;
@@ -60,6 +63,10 @@ export interface AsyncDataOptions<ResT, DataT = ResT, PickKeys extends KeysOf<Da
      * @default 'cancel'
      */
     dedupe?: 'cancel' | 'defer';
+    /**
+     * A timeout in milliseconds after which the request will be aborted if it has not resolved yet.
+     */
+    timeout?: number;
 }
 export interface AsyncDataExecuteOptions {
     /**
@@ -71,6 +78,8 @@ export interface AsyncDataExecuteOptions {
     cause?: AsyncDataRefreshCause;
     /** @internal */
     cachedData?: any;
+    signal?: AbortSignal;
+    timeout?: number;
 }
 export interface _AsyncData<DataT, ErrorT> {
     data: Ref<DataT>;
@@ -89,8 +98,8 @@ export type AsyncData<Data, Error> = _AsyncData<Data, Error> & Promise<_AsyncDat
  * @param handler An asynchronous function that must return a truthy value (for example, it should not be `undefined` or `null`) or the request may be duplicated on the client side.
  * @param options customize the behavior of useAsyncData
  */
-export declare function useAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = undefined>(handler: (ctx?: NuxtApp) => Promise<ResT>, options?: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
-export declare function useAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = DataT>(handler: (ctx?: NuxtApp) => Promise<ResT>, options?: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
+export declare function useAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = undefined>(handler: AsyncDataHandler<ResT>, options?: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
+export declare function useAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = DataT>(handler: AsyncDataHandler<ResT>, options?: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
 /**
  * Provides access to data that resolves asynchronously in an SSR-friendly composable.
  * See {@link https://nuxt.com/docs/4.x/api/composables/use-async-data}
@@ -98,8 +107,8 @@ export declare function useAsyncData<ResT, NuxtErrorDataT = unknown, DataT = Res
  * @param handler An asynchronous function that must return a truthy value (for example, it should not be `undefined` or `null`) or the request may be duplicated on the client side.
  * @param options customize the behavior of useAsyncData
  */
-export declare function useAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = undefined>(key: MaybeRefOrGetter<string>, handler: (ctx?: NuxtApp) => Promise<ResT>, options?: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
-export declare function useAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = DataT>(key: MaybeRefOrGetter<string>, handler: (ctx?: NuxtApp) => Promise<ResT>, options?: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
+export declare function useAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = undefined>(key: MaybeRefOrGetter<string>, handler: AsyncDataHandler<ResT>, options?: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
+export declare function useAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = DataT>(key: MaybeRefOrGetter<string>, handler: AsyncDataHandler<ResT>, options?: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
 /**
  * Provides access to data that resolves asynchronously in an SSR-friendly composable.
  * See {@link https://nuxt.com/docs/4.x/api/composables/use-lazy-async-data}
@@ -107,8 +116,8 @@ export declare function useAsyncData<ResT, NuxtErrorDataT = unknown, DataT = Res
  * @param handler An asynchronous function that must return a truthy value (for example, it should not be `undefined` or `null`) or the request may be duplicated on the client side.
  * @param options customize the behavior of useLazyAsyncData
  */
-export declare function useLazyAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = undefined>(handler: (ctx?: NuxtApp) => Promise<ResT>, options?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'lazy'>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
-export declare function useLazyAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = DataT>(handler: (ctx?: NuxtApp) => Promise<ResT>, options?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'lazy'>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
+export declare function useLazyAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = undefined>(handler: AsyncDataHandler<ResT>, options?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'lazy'>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
+export declare function useLazyAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = DataT>(handler: AsyncDataHandler<ResT>, options?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'lazy'>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
 /**
  * Provides access to data that resolves asynchronously in an SSR-friendly composable.
  * See {@link https://nuxt.com/docs/4.x/api/composables/use-lazy-async-data}
@@ -116,8 +125,8 @@ export declare function useLazyAsyncData<ResT, NuxtErrorDataT = unknown, DataT =
  * @param handler An asynchronous function that must return a truthy value (for example, it should not be `undefined` or `null`) or the request may be duplicated on the client side.
  * @param options customize the behavior of useLazyAsyncData
  */
-export declare function useLazyAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = undefined>(key: MaybeRefOrGetter<string>, handler: (ctx?: NuxtApp) => Promise<ResT>, options?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'lazy'>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
-export declare function useLazyAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = DataT>(key: MaybeRefOrGetter<string>, handler: (ctx?: NuxtApp) => Promise<ResT>, options?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'lazy'>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
+export declare function useLazyAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = undefined>(key: MaybeRefOrGetter<string>, handler: AsyncDataHandler<ResT>, options?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'lazy'>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
+export declare function useLazyAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = DataT>(key: MaybeRefOrGetter<string>, handler: AsyncDataHandler<ResT>, options?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'lazy'>): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>;
 /** @since 3.1.0 */
 export declare function useNuxtData<DataT = any>(key: string): {
     data: Ref<DataT | undefined>;
@@ -133,4 +142,5 @@ export type CreatedAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, Defau
     _init: boolean;
     _deps: number;
     _execute: (opts?: AsyncDataExecuteOptions) => Promise<void>;
+    _abortController?: AbortController;
 };
diff --git a/dist/app/composables/asyncData.js b/dist/app/composables/asyncData.js
index c1140eea00efa15d61db0deb26a61403f99a44e2..c6baf2ef63ff05383f85b6693b890d1deac1d197 100644
--- a/dist/app/composables/asyncData.js
+++ b/dist/app/composables/asyncData.js
@@ -174,7 +174,17 @@ You can use a different key or move the call to a composable to ensure the optio
       return nuxtApp._asyncData[key.value].execute(...args2);
     },
     execute: (...args2) => asyncReturn.refresh(...args2),
-    clear: () => clearNuxtDataByKey(nuxtApp, key.value)
+    clear: () => {
+      const entry = nuxtApp._asyncData[key.value];
+      if (entry?._abortController) {
+        try {
+          entry._abortController.abort(new DOMException("AsyncData aborted by user.", "AbortError"));
+        } finally {
+          entry._abortController = void 0;
+        }
+      }
+      clearNuxtDataByKey(nuxtApp, key.value);
+    }
   };
   const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key.value]).then(() => asyncReturn);
   Object.assign(asyncDataPromise, asyncReturn);
@@ -280,9 +290,6 @@ function clearNuxtDataByKey(nuxtApp, key) {
     nuxtApp._asyncData[key].status.value = "idle";
   }
   if (key in nuxtApp._asyncDataPromises) {
-    if (nuxtApp._asyncDataPromises[key]) {
-      nuxtApp._asyncDataPromises[key].cancelled = true;
-    }
     nuxtApp._asyncDataPromises[key] = void 0;
   }
 }
@@ -296,13 +303,13 @@ function pick(obj, keys) {
 function createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {
   nuxtApp.payload._errors[key] ??= void 0;
   const hasCustomGetCachedData = options.getCachedData !== getDefaultCachedData;
-  const handler = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?._sharedPrerenderCache ? _handler : () => {
-    const value = nuxtApp.ssrContext._sharedPrerenderCache.get(key);
+  const handler = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?._sharedPrerenderCache ? _handler : (nuxtApp2, options2) => {
+    const value = nuxtApp2.ssrContext._sharedPrerenderCache.get(key);
     if (value) {
       return value;
     }
-    const promise = Promise.resolve().then(() => nuxtApp.runWithContext(() => _handler(nuxtApp)));
-    nuxtApp.ssrContext._sharedPrerenderCache.set(key, promise);
+    const promise = Promise.resolve().then(() => nuxtApp2.runWithContext(() => _handler(nuxtApp2, options2)));
+    nuxtApp2.ssrContext._sharedPrerenderCache.set(key, promise);
     return promise;
   };
   const _ref = options.deep ? ref : shallowRef;
@@ -327,7 +334,6 @@ function createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {
         if ((opts.dedupe ?? options.dedupe) === "defer") {
           return nuxtApp._asyncDataPromises[key];
         }
-        nuxtApp._asyncDataPromises[key].cancelled = true;
       }
       if (granularCachedData || opts.cause === "initial" || nuxtApp.isHydrating) {
         const cachedData = "cachedData" in opts ? opts.cachedData : options.getCachedData(key, nuxtApp, { cause: opts.cause ?? "refresh:manual" });
@@ -341,19 +347,31 @@ function createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {
       if (pendingWhenIdle) {
         asyncData.pending.value = true;
       }
+      if (asyncData._abortController) {
+        asyncData._abortController.abort(new DOMException("AsyncData request cancelled by deduplication", "AbortError"));
+      }
+      asyncData._abortController = new AbortController();
       asyncData.status.value = "pending";
       const promise = new Promise(
         (resolve, reject) => {
           try {
-            resolve(handler(nuxtApp));
+            const timeout = opts.timeout ?? options.timeout;
+            const mergedSignal = mergeAbortSignals([asyncData._abortController?.signal, opts?.signal], timeout);
+            if (mergedSignal.aborted) {
+              const reason = mergedSignal.reason;
+              reject(reason instanceof Error ? reason : new DOMException(String(reason ?? "Aborted"), "AbortError"));
+              return;
+            }
+            mergedSignal.addEventListener("abort", () => {
+              const reason = mergedSignal.reason;
+              reject(reason instanceof Error ? reason : new DOMException(String(reason ?? "Aborted"), "AbortError"));
+            }, { once: true });
+            return Promise.resolve(handler(nuxtApp, { signal: mergedSignal })).then(resolve, reject);
           } catch (err) {
             reject(err);
           }
         }
       ).then(async (_result) => {
-        if (promise.cancelled) {
-          return nuxtApp._asyncDataPromises[key];
-        }
         let result = _result;
         if (options.transform) {
           result = await options.transform(_result);
@@ -371,16 +389,20 @@ function createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {
         asyncData.error.value = void 0;
         asyncData.status.value = "success";
       }).catch((error) => {
-        if (promise.cancelled) {
-          return nuxtApp._asyncDataPromises[key];
+        if (nuxtApp._asyncDataPromises[key] && nuxtApp._asyncDataPromises[key] !== promise) {
+          return;
+        }
+        if (asyncData._abortController?.signal.aborted) {
+          return;
+        }
+        if (typeof DOMException !== "undefined" && error instanceof DOMException && error.name === "AbortError") {
+          asyncData.status.value = "idle";
+          return;
         }
         asyncData.error.value = createError(error);
         asyncData.data.value = unref(options.default());
         asyncData.status.value = "error";
       }).finally(() => {
-        if (promise.cancelled) {
-          return;
-        }
         if (pendingWhenIdle) {
           asyncData.pending.value = false;
         }
@@ -428,3 +450,40 @@ function createHash(_handler, options) {
     getCachedData: options.getCachedData ? hash(options.getCachedData) : void 0
   };
 }
+function mergeAbortSignals(signals, timeout) {
+  const list = signals.filter((s) => !!s);
+  if (typeof timeout === "number" && timeout >= 0) {
+    const timeoutSignal = AbortSignal.timeout?.(timeout);
+    if (timeoutSignal) {
+      list.push(timeoutSignal);
+    }
+  }
+  if (AbortSignal.any) {
+    return AbortSignal.any(list);
+  }
+  const controller = new AbortController();
+  for (const sig of list) {
+    if (sig.aborted) {
+      const reason = sig.reason ?? new DOMException("Aborted", "AbortError");
+      try {
+        controller.abort(reason);
+      } catch {
+        controller.abort();
+      }
+      return controller.signal;
+    }
+  }
+  const onAbort = () => {
+    const abortedSignal = list.find((s) => s.aborted);
+    const reason = abortedSignal?.reason ?? new DOMException("Aborted", "AbortError");
+    try {
+      controller.abort(reason);
+    } catch {
+      controller.abort();
+    }
+  };
+  for (const sig of list) {
+    sig.addEventListener?.("abort", onAbort, { once: true });
+  }
+  return controller.signal;
+}
diff --git a/dist/app/composables/fetch.d.ts b/dist/app/composables/fetch.d.ts
index 446e00ad0b30c48a28a5b6b1a23d626fa89459b7..e2acf83ed4164a2ae38ca632c823312c73051a7d 100644
--- a/dist/app/composables/fetch.d.ts
+++ b/dist/app/composables/fetch.d.ts
@@ -11,7 +11,7 @@ interface NitroFetchOptions<R extends NitroFetchRequest, M extends AvailableRout
     method?: M;
 }
 type ComputedFetchOptions<R extends NitroFetchRequest, M extends AvailableRouterMethod<R>, DataT = any> = ComputedOptions<NitroFetchOptions<R, M, DataT>>;
-export interface UseFetchOptions<ResT, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = undefined, R extends NitroFetchRequest = string & {}, M extends AvailableRouterMethod<R> = AvailableRouterMethod<R>> extends Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'watch'>, ComputedFetchOptions<R, M, DataT> {
+export interface UseFetchOptions<ResT, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>, DefaultT = undefined, R extends NitroFetchRequest = string & {}, M extends AvailableRouterMethod<R> = AvailableRouterMethod<R>> extends Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'watch'>, Omit<ComputedFetchOptions<R, M, DataT>, 'timeout'> {
     key?: MaybeRefOrGetter<string>;
     $fetch?: typeof globalThis.$fetch;
     watch?: MultiWatchSources | false;
diff --git a/dist/app/composables/fetch.js b/dist/app/composables/fetch.js
index 2447b55bb89e2fb1ad667e2f9f57691becfddf03..c688082b475d731171ad924ac9535bc16ea9f9c5 100644
--- a/dist/app/composables/fetch.js
+++ b/dist/app/composables/fetch.js
@@ -22,6 +22,7 @@ export function useFetch(request, arg1, arg2) {
     getCachedData,
     deep,
     dedupe,
+    timeout,
     ...fetchOptions
   } = opts;
   const _fetchOptions = reactive({
@@ -39,6 +40,7 @@ export function useFetch(request, arg1, arg2) {
     getCachedData,
     deep,
     dedupe,
+    timeout,
     watch: watchSources === false ? [] : [...watchSources || [], _fetchOptions]
   };
   if (import.meta.dev) {
@@ -51,16 +53,7 @@ export function useFetch(request, arg1, arg2) {
     watch(key, setImmediate, { flush: "sync", once: true });
     watch([...watchSources || [], _fetchOptions], setImmediate, { flush: "sync", once: true });
   }
-  let controller;
-  const asyncData = useAsyncData(watchSources === false ? key.value : key, () => {
-    controller?.abort?.(new DOMException("Request aborted as another request to the same endpoint was initiated.", "AbortError"));
-    controller = typeof AbortController !== "undefined" ? new AbortController() : {};
-    const timeoutLength = toValue(opts.timeout);
-    let timeoutId;
-    if (timeoutLength) {
-      timeoutId = setTimeout(() => controller.abort(new DOMException("Request aborted due to timeout.", "AbortError")), timeoutLength);
-      controller.signal.onabort = () => clearTimeout(timeoutId);
-    }
+  const asyncData = useAsyncData(watchSources === false ? key.value : key, (_, { signal }) => {
     let _$fetch = opts.$fetch || globalThis.$fetch;
     if (import.meta.server && !opts.$fetch) {
       const isLocalFetch = typeof _request.value === "string" && _request.value[0] === "/" && (!toValue(opts.baseURL) || toValue(opts.baseURL)[0] === "/");
@@ -68,9 +61,7 @@ export function useFetch(request, arg1, arg2) {
         _$fetch = useRequestFetch();
       }
     }
-    return _$fetch(_request.value, { signal: controller.signal, ..._fetchOptions }).finally(() => {
-      clearTimeout(timeoutId);
-    });
+    return _$fetch(_request.value, { signal, ..._fetchOptions });
   }, _asyncDataOptions);
   return asyncData;
 }
diff --git a/dist/app/deserialize.d.ts b/dist/app/deserialize.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2f07a2fdeb3e30b09fb39572fda159387059cdad
--- /dev/null
+++ b/dist/app/deserialize.d.ts
@@ -0,0 +1,4 @@
+import { type VNode } from "vue";
+import { type VServerComponent } from "./shared.js";
+export declare function renderServerComponent(input?: VServerComponent): VNode | undefined;
+export declare function renderChildren(data: VServerComponent | VServerComponent[] | undefined): VNode | undefined;
diff --git a/dist/app/deserialize.js b/dist/app/deserialize.js
new file mode 100644
index 0000000000000000000000000000000000000000..4cdf208b89739d33cf180de20c10f9a916fd630e
--- /dev/null
+++ b/dist/app/deserialize.js
@@ -0,0 +1,30 @@
+import { createTextVNode, h, Fragment, Suspense } from "vue";
+import { VServerComponentType } from "./shared";
+import loader from "./components/loader";
+export function renderServerComponent(input) {
+  if (!input) return;
+  if (input.type === VServerComponentType.Text) {
+    return createTextVNode(input.text);
+  }
+  if (input.type === VServerComponentType.Element) {
+    return h(input.tag, input.props, Array.isArray(input.children) ? input.children.map(renderServerComponent) : renderServerComponent(input.children));
+  }
+  if (input.type === VServerComponentType.Component) {
+    return h(Suspense, {}, {
+      default: () => h(loader, {
+        data: input
+      })
+    });
+  }
+  if (input.type === VServerComponentType.Fragment) {
+    return Array.isArray(input.children) ? h(Fragment, input.children.map(renderServerComponent)) : renderServerComponent(input.children);
+  }
+}
+export function renderChildren(data) {
+  if (!data) return;
+  if (Array.isArray(data)) {
+    return h(Fragment, data.map(renderServerComponent));
+  } else {
+    return renderServerComponent(data);
+  }
+}
diff --git a/dist/app/entry.js b/dist/app/entry.js
index e6821aaa297411937119f71de6d86c3c2b8b2343..fcb30f22c04cf66d994f86943377065a5f617bbc 100644
--- a/dist/app/entry.js
+++ b/dist/app/entry.js
@@ -10,7 +10,7 @@ import { appId, appSpaLoaderAttrs, multiApp, spaLoadingTemplateOutside, vueAppRo
 let entry;
 if (import.meta.server) {
   entry = async function createNuxtAppServer(ssrContext) {
-    const vueApp = createApp(RootComponent);
+    const vueApp = createApp(ssrContext?.rootComponent ?? RootComponent, ssrContext?.islandContext?.props);
     const nuxt = createNuxtApp({ vueApp, ssrContext });
     try {
       await applyPlugins(nuxt, plugins);
diff --git a/dist/app/island.d.ts b/dist/app/island.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..df62284ee8906db0ac4abab8abbd0064753a0ae0
--- /dev/null
+++ b/dist/app/island.d.ts
@@ -0,0 +1,7 @@
+import type { SSRContext } from "vue/server-renderer";
+import type { App, DefineComponent, VNode } from "vue";
+export declare function renderIsland(_component: DefineComponent, props: any, context?: SSRContext): Promise<any>;
+export declare function renderAsServerComponent(input: App | VNode, context?: SSRContext, props?: any): Promise<{
+    html: string;
+    ast: any;
+}>;
diff --git a/dist/app/island.js b/dist/app/island.js
new file mode 100644
index 0000000000000000000000000000000000000000..83f3a64b2f8c15845c4c2f9a4a9f40814d62d56f
--- /dev/null
+++ b/dist/app/island.js
@@ -0,0 +1,24 @@
+import { isVNode, createApp } from "vue";
+import { renderToString } from "vue/server-renderer";
+import { renderToAST } from "./serialize";
+import { h } from "vue";
+export async function renderIsland(_component, props, context = {}) {
+  const component = _component.__vnodeVersion ? await import(_component.__vnodeVersion).then((m) => m.default || m) : _component;
+  const app = createApp(() => h(component, props));
+  return await renderToAST(app, context);
+}
+export async function renderAsServerComponent(input, context = {}, props) {
+  if (isVNode(input)) {
+    return renderAsServerComponent(createApp({ render: () => input }), context);
+  }
+  if (!input.version) {
+    return renderAsServerComponent(createApp(input, props), context);
+  }
+  const htmlPromise = renderToString(input, context);
+  const astPromise = renderToAST(input, context);
+  const [html, ast] = await Promise.all([htmlPromise, astPromise]);
+  return {
+    html,
+    ast
+  };
+}
diff --git a/dist/app/middleware/manifest-route-rule.js b/dist/app/middleware/manifest-route-rule.js
index 9b0134ae15b0b50d4bdbff75c5522f0d838d72b3..0c8734c72296978cc0ac211ace9706da7b41ed93 100644
--- a/dist/app/middleware/manifest-route-rule.js
+++ b/dist/app/middleware/manifest-route-rule.js
@@ -7,10 +7,11 @@ export default defineNuxtRouteMiddleware(async (to) => {
   }
   const rules = await getRouteRules({ path: to.path });
   if (rules.redirect) {
-    if (hasProtocol(rules.redirect, { acceptRelative: true })) {
-      window.location.href = rules.redirect;
+    const path = rules.redirect.includes("#") ? rules.redirect : rules.redirect + to.hash;
+    if (hasProtocol(path, { acceptRelative: true })) {
+      window.location.href = path;
       return false;
     }
-    return rules.redirect;
+    return path;
   }
 });
diff --git a/dist/app/nuxt.d.ts b/dist/app/nuxt.d.ts
index 3fe5d7eafb308564f6e664ee933688a29667d1f5..13c020f84c116115eaec557f9c441c76224a2805 100644
--- a/dist/app/nuxt.d.ts
+++ b/dist/app/nuxt.d.ts
@@ -73,6 +73,7 @@ export interface NuxtSSRContext extends SSRContext {
     };
     /** @internal */
     _preloadManifest?: boolean;
+    rootComponent?: VNode;
 }
 export interface NuxtPayload {
     path?: string;
@@ -123,6 +124,8 @@ interface _NuxtApp {
         _execute: (opts?: AsyncDataExecuteOptions) => Promise<void>;
         /** @internal */
         _hash?: Record<string, string | undefined>;
+        /** @internal */
+        _abortController?: AbortController;
     } | undefined>;
     /** @internal */
     _loadingIndicator?: LoadingIndicator;
diff --git a/dist/core/runtime/nitro/handlers/error.js b/dist/core/runtime/nitro/handlers/error.js
index 1c837516ea028281dda3e34ea7d9e49997526a0d..df17a9b8aa9e1880a2dbddd7f41127f8855ea31d 100644
--- a/dist/core/runtime/nitro/handlers/error.js
+++ b/dist/core/runtime/nitro/handlers/error.js
@@ -2,6 +2,7 @@ import { joinURL, withQuery, withoutBase } from "ufo";
 import { appendResponseHeader, getRequestHeaders, send, setResponseHeader, setResponseHeaders, setResponseStatus } from "h3";
 import { useNitroApp, useRuntimeConfig } from "nitropack/runtime";
 import { isJsonRequest } from "../utils/error.js";
+import { generateErrorOverlayHTML } from "../utils/dev.js";
 export default (async function errorhandler(error, event, { defaultHandler }) {
   if (event.handled || isJsonRequest(event)) {
     return;
@@ -38,7 +39,7 @@ export default (async function errorhandler(error, event, { defaultHandler }) {
     return;
   }
   if (!res) {
-    const { template } = import.meta.dev ? await import("../templates/error-dev") : await import("../templates/error-500");
+    const { template } = await import("../templates/error-500.js");
     if (import.meta.dev) {
       errorObject.description = errorObject.message;
     }
@@ -54,5 +55,9 @@ export default (async function errorhandler(error, event, { defaultHandler }) {
     setResponseHeader(event, header, value);
   }
   setResponseStatus(event, res.status && res.status !== 200 ? res.status : defaultRes.status, res.statusText || defaultRes.statusText);
+  if (import.meta.dev) {
+    const prettyResponse = await defaultHandler(error, event, { json: false });
+    return send(event, html.replace("</body>", `${generateErrorOverlayHTML(prettyResponse.body)}</body>`));
+  }
   return send(event, html);
 });
diff --git a/dist/core/runtime/nitro/handlers/island.js b/dist/core/runtime/nitro/handlers/island.js
index 50eb45513a4b50648461d71ec214f32bf8796960..4af757b56a6dbf38788430df2874d0b46dd604e5 100644
--- a/dist/core/runtime/nitro/handlers/island.js
+++ b/dist/core/runtime/nitro/handlers/island.js
@@ -4,11 +4,12 @@ import { defineEventHandler, getQuery, readBody, setResponseHeaders } from "h3";
 import { resolveUnrefHeadInput } from "@unhead/vue";
 import { getRequestDependencies } from "vue-bundle-renderer/runtime";
 import { getQuery as getURLQuery } from "ufo";
+import { serializeApp } from "vue-onigiri/runtime/serialize";
 import { islandCache, islandPropCache } from "../utils/cache.js";
 import { createSSRContext } from "../utils/renderer/app.js";
-import { getSSRRenderer } from "../utils/renderer/build-files.js";
+import { getComponentsIslands, getSSRRenderer, getServerEntry } from "../utils/renderer/build-files.js";
 import { renderInlineStyles } from "../utils/renderer/inline-styles.js";
-import { getClientIslandResponse, getServerComponentHTML, getSlotIslandResponse } from "../utils/renderer/islands.js";
+const components = (await getComponentsIslands()).islandComponents;
 const ISLAND_SUFFIX_RE = /\.json(?:\?.*)?$/;
 export default defineEventHandler(async (event) => {
   const nitroApp = useNitroApp();
@@ -27,15 +28,15 @@ export default defineEventHandler(async (event) => {
     url: islandContext.url
   };
   const renderer = await getSSRRenderer();
-  const renderResult = await renderer.renderToString(ssrContext).catch(async (err) => {
-    await ssrContext.nuxt?.hooks.callHook("app:error", err);
-    throw err;
-  });
+  const createSSRApp = await getServerEntry();
+  ssrContext.rootComponent = components[islandContext.name];
+  const app = await createSSRApp(ssrContext, renderer.rendererContext);
+  const ast = await app.runWithContext(() => serializeApp(app, ssrContext));
   if (ssrContext.payload?.error) {
     throw ssrContext.payload.error;
   }
   const inlinedStyles = await renderInlineStyles(ssrContext.modules ?? []);
-  await ssrContext.nuxt?.hooks.callHook("app:rendered", { ssrContext, renderResult });
+  await ssrContext.nuxt?.hooks.callHook("app:rendered", { ssrContext });
   if (inlinedStyles.length) {
     ssrContext.head.push({ style: inlinedStyles });
   }
@@ -47,7 +48,7 @@ export default defineEventHandler(async (event) => {
         continue;
       }
       if (resource.file.includes("scoped") && !resource.file.includes("pages/")) {
-        link.push({ rel: "stylesheet", href: renderer.rendererContext.buildAssetsURL(resource.file), crossorigin: "" });
+        link.push({ rel: "stylesheet", href: renderer.rendererContext.buildAssetsURL(resource.file.replace("virtual:vsc:", "")), crossorigin: "" });
       }
     }
     if (link.length) {
@@ -67,9 +68,7 @@ export default defineEventHandler(async (event) => {
   const islandResponse = {
     id: islandContext.id,
     head: islandHead,
-    html: getServerComponentHTML(renderResult.html),
-    components: getClientIslandResponse(ssrContext),
-    slots: getSlotIslandResponse(ssrContext)
+    ast
   };
   await nitroApp.hooks.callHook("render:island", islandResponse, { event, islandContext });
   if (import.meta.prerender) {
diff --git a/dist/core/runtime/nitro/handlers/renderer.js b/dist/core/runtime/nitro/handlers/renderer.js
index 7a97ee4e0a594f4fc62e3cbbf09e2bfd26899b73..821c1794dd6082e956ff3ae1de496648d77c352a 100644
--- a/dist/core/runtime/nitro/handlers/renderer.js
+++ b/dist/core/runtime/nitro/handlers/renderer.js
@@ -10,14 +10,14 @@ import { getQuery as getURLQuery, joinURL } from "ufo";
 import { propsToString, renderSSRHead } from "@unhead/vue/server";
 import destr from "destr";
 import { defineRenderHandler, getRouteRules, useNitroApp } from "nitropack/runtime";
-import { getEntryIds, getRenderer } from "../utils/renderer/build-files.js";
+import { getRenderer } from "../utils/renderer/build-files.js";
 import { payloadCache } from "../utils/cache.js";
 import { renderPayloadJsonScript, renderPayloadResponse, renderPayloadScript, splitPayload } from "../utils/renderer/payload.js";
 import { createSSRContext, setSSRError } from "../utils/renderer/app.js";
 import { renderInlineStyles } from "../utils/renderer/inline-styles.js";
-import { replaceIslandTeleports } from "../utils/renderer/islands.js";
 import { renderSSRHeadOptions } from "#internal/unhead.config.mjs";
-import { appHead, appTeleportAttrs, appTeleportTag, componentIslands, appManifest as isAppManifestEnabled } from "#internal/nuxt.config.mjs";
+import { appHead, appTeleportAttrs, appTeleportTag, appManifest as isAppManifestEnabled } from "#internal/nuxt.config.mjs";
+import entryIds from "#internal/nuxt/entry-ids.mjs";
 import { entryFileName } from "#internal/entry-chunk.mjs";
 import { buildAssetsURL, publicAssetsURL } from "#internal/nuxt/paths";
 import { relative } from "pathe";
@@ -77,7 +77,7 @@ export default defineRenderHandler(async (event) => {
     }
   }
   if (process.env.NUXT_INLINE_STYLES) {
-    for (const id of await getEntryIds()) {
+    for (const id of entryIds) {
       ssrContext.modules.add(id);
     }
   }
@@ -150,7 +150,7 @@ export default defineRenderHandler(async (event) => {
     ssrContext.head.push({ style: inlinedStyles });
   }
   const link = [];
-  for (const resource of Object.values(styles)) {
+  for (const resource of Object.values(styles).filter((r) => !r.file.includes("virtual:vsc:"))) {
     if (import.meta.dev && "inline" in getURLQuery(resource.file)) {
       continue;
     }
@@ -161,10 +161,10 @@ export default defineRenderHandler(async (event) => {
   }
   if (!NO_SCRIPTS) {
     ssrContext.head.push({
-      link: getPreloadLinks(ssrContext, renderer.rendererContext)
+      link: getPreloadLinks(ssrContext, renderer.rendererContext).filter((l) => !l.href.includes("virtual:vsc:"))
     }, headEntryOptions);
     ssrContext.head.push({
-      link: getPrefetchLinks(ssrContext, renderer.rendererContext)
+      link: getPrefetchLinks(ssrContext, renderer.rendererContext).filter((l) => !l.href.includes("virtual:vsc:"))
     }, headEntryOptions);
     ssrContext.head.push({
       script: _PAYLOAD_EXTRACTION ? process.env.NUXT_JSON_PAYLOADS ? renderPayloadJsonScript({ ssrContext, data: splitPayload(ssrContext).initial, src: payloadURL }) : renderPayloadScript({ ssrContext, data: splitPayload(ssrContext).initial, src: payloadURL }) : process.env.NUXT_JSON_PAYLOADS ? renderPayloadJsonScript({ ssrContext, data: ssrContext.payload }) : renderPayloadScript({ ssrContext, data: ssrContext.payload })
@@ -196,7 +196,7 @@ export default defineRenderHandler(async (event) => {
     bodyAttrs: bodyAttrs ? [bodyAttrs] : [],
     bodyPrepend: normalizeChunks([bodyTagsOpen, ssrContext.teleports?.body]),
     body: [
-      componentIslands ? replaceIslandTeleports(ssrContext, _rendered.html) : _rendered.html,
+      _rendered.html,
       APP_TELEPORT_OPEN_TAG + (HAS_APP_TELEPORTS ? joinTags([ssrContext.teleports?.[`#${appTeleportAttrs.id}`]]) : "") + APP_TELEPORT_CLOSE_TAG
     ],
     bodyAppend: [bodyTags]
diff --git a/dist/core/runtime/nitro/utils/dev.d.ts b/dist/core/runtime/nitro/utils/dev.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a47e23331c21b2b89d6da5ae47775055806bbb06
--- /dev/null
+++ b/dist/core/runtime/nitro/utils/dev.d.ts
@@ -0,0 +1 @@
+export declare function generateErrorOverlayHTML(html: string): string;
diff --git a/dist/core/runtime/nitro/utils/dev.js b/dist/core/runtime/nitro/utils/dev.js
new file mode 100644
index 0000000000000000000000000000000000000000..2327e5a994862a7bc61ac04119842bfe742aa2ac
--- /dev/null
+++ b/dist/core/runtime/nitro/utils/dev.js
@@ -0,0 +1,328 @@
+const iframeStorageBridge = (nonce) => (
+  /* js */
+  `
+(function() {
+  const memoryStore = {};
+
+  const NONCE = ${JSON.stringify(nonce)}
+  
+  const mockStorage = {
+    getItem: function(key) {
+      return memoryStore[key] !== undefined ? memoryStore[key] : null;
+    },
+    setItem: function(key, value) {
+      memoryStore[key] = String(value);
+      window.parent.postMessage({
+        type: 'storage-set',
+        key: key,
+        value: String(value),
+        nonce: NONCE
+      }, '*');
+    },
+    removeItem: function(key) {
+      delete memoryStore[key];
+      window.parent.postMessage({
+        type: 'storage-remove',
+        key: key,
+        nonce: NONCE
+      }, '*');
+    },
+    clear: function() {
+      for (const key in memoryStore) {
+        delete memoryStore[key];
+      }
+      window.parent.postMessage({
+        type: 'storage-clear',
+        nonce: NONCE
+      }, '*');
+    },
+    key: function(index) {
+      const keys = Object.keys(memoryStore);
+      return keys[index] !== undefined ? keys[index] : null;
+    },
+    get length() {
+      return Object.keys(memoryStore).length;
+    }
+  };
+  
+  try {
+    Object.defineProperty(window, 'localStorage', {
+      value: mockStorage,
+      writable: false,
+      configurable: true
+    });
+  } catch (e) {
+    window.localStorage = mockStorage;
+  }
+  
+  window.addEventListener('message', function(event) {
+    if (event.data.type === 'storage-sync-data' && event.data.nonce === NONCE) {
+      const data = event.data.data;
+      for (const key in data) {
+        if (Object.prototype.hasOwnProperty.call(data, key)) {
+          memoryStore[key] = data[key];
+        }
+      }
+      if (typeof window.initTheme === 'function') {
+        window.initTheme();
+      }
+      window.dispatchEvent(new Event('storage-ready'));
+    }
+  });
+  
+  window.parent.postMessage({ 
+    type: 'storage-sync-request',
+    nonce: NONCE
+  }, '*');
+})();
+`
+);
+const parentStorageBridge = (nonce) => (
+  /* js */
+  `
+(function() {
+  const host = document.querySelector('nuxt-error-overlay');
+  if (!host) return;
+  
+  // Wait for shadow root to be attached
+  const checkShadow = setInterval(function() {
+    if (host.shadowRoot) {
+      clearInterval(checkShadow);
+      const iframe = host.shadowRoot.getElementById('frame');
+      if (!iframe) return;
+
+      const NONCE = ${JSON.stringify(nonce)}
+      
+      window.addEventListener('message', function(event) {
+        if (!event.data || event.data.nonce !== NONCE) return;
+        
+        const data = event.data;
+        
+        if (data.type === 'storage-set') {
+          localStorage.setItem(data.key, data.value);
+        } else if (data.type === 'storage-remove') {
+          localStorage.removeItem(data.key);
+        } else if (data.type === 'storage-clear') {
+          localStorage.clear();
+        } else if (data.type === 'storage-sync-request') {
+          const allData = {};
+          for (let i = 0; i < localStorage.length; i++) {
+            const key = localStorage.key(i);
+            allData[key] = localStorage.getItem(key);
+          }
+          iframe.contentWindow.postMessage({
+            type: 'storage-sync-data',
+            data: allData,
+            nonce: NONCE
+          }, '*');
+        }
+      });
+    }
+  }, 10);
+})();
+`
+);
+const errorCSS = (
+  /* css */
+  `
+:host {
+  --preview-width: 240px;
+  --preview-height: 180px;
+  --base-width: 1200px;
+  --base-height: 900px;
+  --z-base: 999999998;
+  all: initial;
+  display: contents;
+}
+.sr-only {
+  position: absolute;
+  width: 1px;
+  height: 1px;
+  padding: 0;
+  margin: -1px;
+  overflow: hidden;
+  clip: rect(0, 0, 0, 0);
+  white-space: nowrap;
+  border-width: 0;
+}
+#frame {
+  position: fixed;
+  left: 0;
+  top: 0;
+  width: 100vw;
+  height: 100vh;
+  z-index: var(--z-base);
+}
+#frame[inert] {
+  right: 5px;
+  bottom: 5px;
+  left: auto;
+  top: auto;
+  width: var(--base-width);
+  height: var(--base-height);
+  transform: scale(calc(240 / 1200));
+  transform-origin: bottom right;
+  overflow: hidden;
+  border-radius: calc(1200 * 8px / 240);
+}
+#preview {
+  position: fixed;
+  right: 5px;
+  bottom: 5px;
+  width: var(--preview-width);
+  height: var(--preview-height);
+  overflow: hidden;
+  border-radius: 8px;
+  pointer-events: none;
+  z-index: var(--z-base);
+  background: white;
+  display: none;
+}
+#frame:not([inert]) + #preview {
+  display: block;
+}
+#toggle {
+  position: fixed;
+  right: 5px;
+  bottom: 5px;
+  width: var(--preview-width);
+  height: var(--preview-height);
+  background: none;
+  border: 3px solid #00DC82;
+  border-radius: 8px;
+  cursor: pointer;
+  opacity: 0.8;
+  transition: opacity 0.2s, box-shadow 0.2s;
+  z-index: calc(var(--z-base) + 1);
+}
+#toggle:hover,
+#toggle:focus {
+  opacity: 1;
+  box-shadow: 0 0 20px rgba(0, 220, 130, 0.6);
+}
+#toggle:focus-visible {
+  outline: 3px solid #00DC82;
+  outline-offset: 3px;
+  box-shadow: 0 0 24px rgba(0, 220, 130, 0.8);
+}
+@media (prefers-reduced-motion: reduce) {
+  #toggle {
+    transition: none;
+  }
+}
+`
+);
+function webComponentScript(base64HTML) {
+  return (
+    /* js */
+    `
+  (function() {
+    try {
+      const host = document.querySelector('nuxt-error-overlay');
+      if (!host) return;
+      
+      const shadow = host.attachShadow({ mode: 'open' });
+      
+      // Create elements
+      const style = document.createElement('style');
+      style.textContent = ${JSON.stringify(errorCSS)};
+      
+      const iframe = document.createElement('iframe');
+      iframe.id = 'frame';
+      iframe.src = 'data:text/html;base64,${base64HTML}';
+      iframe.title = 'Detailed error stack trace';
+      iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');
+      
+      const preview = document.createElement('div');
+      preview.id = 'preview';
+      
+      const button = document.createElement('button');
+      button.id = 'toggle';
+      button.setAttribute('aria-expanded', 'true');
+      button.setAttribute('type', 'button');
+      button.innerHTML = '<span class="sr-only">Toggle detailed error view</span>';
+      
+      const liveRegion = document.createElement('div');
+      liveRegion.setAttribute('role', 'status');
+      liveRegion.setAttribute('aria-live', 'polite');
+      liveRegion.className = 'sr-only';
+      
+      // Update preview snapshot
+      function updatePreview() {
+        try {
+          let previewIframe = preview.querySelector('iframe');
+          if (!previewIframe) {
+            previewIframe = document.createElement('iframe');
+            previewIframe.style.cssText = 'width: 1200px; height: 900px; transform: scale(0.2); transform-origin: top left; border: none;';
+            previewIframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');
+            preview.appendChild(previewIframe);
+          }
+          
+          const doctype = document.doctype ? '<!DOCTYPE ' + document.doctype.name + '>' : '';
+          const cleanedHTML = document.documentElement.outerHTML
+            .replace(/<nuxt-error-overlay[^>]*>.*?<\\/nuxt-error-overlay>/gs, '')
+            .replace(/<script[^>]*>.*?<\\/script>/gs, '');
+          
+          const iframeDoc = previewIframe.contentDocument || previewIframe.contentWindow.document;
+          iframeDoc.open();
+          iframeDoc.write(doctype + cleanedHTML);
+          iframeDoc.close();
+        } catch (error) {
+          console.error('Failed to update preview:', error);
+        }
+      }
+      
+      function toggleView() {
+        const isMinimized = iframe.hasAttribute('inert');
+        
+        if (isMinimized) {
+          updatePreview();
+          iframe.removeAttribute('inert');
+          button.setAttribute('aria-expanded', 'true');
+          liveRegion.textContent = 'Showing detailed error view';
+          setTimeout(function() {
+            try { iframe.contentWindow.focus(); } catch {}
+          }, 100);
+        } else {
+          iframe.setAttribute('inert', '');
+          button.setAttribute('aria-expanded', 'false');
+          liveRegion.textContent = 'Showing error page';
+          button.focus();
+        }
+      }
+      
+      button.onclick = toggleView;
+      
+      document.addEventListener('keydown', function(e) {
+        if ((e.key === 'Escape' || e.key === 'Esc') && !iframe.hasAttribute('inert')) {
+          toggleView();
+        }
+      });
+      
+      // Append to shadow DOM
+      shadow.appendChild(style);
+      shadow.appendChild(liveRegion);
+      shadow.appendChild(iframe);
+      shadow.appendChild(preview);
+      shadow.appendChild(button);
+      
+      // Initialize preview
+      setTimeout(updatePreview, 100);
+      
+    } catch (error) {
+      console.error('Failed to initialize Nuxt error overlay:', error);
+    }
+  })();
+  `
+  );
+}
+export function generateErrorOverlayHTML(html) {
+  const nonce = Array.from(crypto.getRandomValues(new Uint8Array(16)), (b) => b.toString(16).padStart(2, "0")).join("");
+  const errorPage = html.replace("<head>", `<head><script>${iframeStorageBridge(nonce)}<\/script>`);
+  const base64HTML = Buffer.from(errorPage, "utf8").toString("base64");
+  return `
+    <script>${parentStorageBridge(nonce)}<\/script>
+    <nuxt-error-overlay></nuxt-error-overlay>
+    <script>${webComponentScript(base64HTML)}<\/script>
+  `;
+}
diff --git a/dist/core/runtime/nitro/utils/renderer/build-files.d.ts b/dist/core/runtime/nitro/utils/renderer/build-files.d.ts
index 53ccf5705763b46fde817535789b2712b1d7853c..e262dd3a7f6245bb58b8db95c147df7fb65536d9 100644
--- a/dist/core/runtime/nitro/utils/renderer/build-files.d.ts
+++ b/dist/core/runtime/nitro/utils/renderer/build-files.d.ts
@@ -1,4 +1,6 @@
 import type { NuxtSSRContext } from 'nuxt/app';
+export declare const getServerEntry: () => Promise<any>;
+export declare const getComponentsIslands: () => Promise<any>;
 export declare const getSSRRenderer: () => Promise<{
     rendererContext: import("vue-bundle-renderer/runtime").RendererContext;
     renderToString(ssrContext: import("vue-bundle-renderer/runtime").SSRContext): Promise<{
@@ -20,4 +22,3 @@ export declare function getRenderer(ssrContext: NuxtSSRContext): Promise<{
     }>;
 }>;
 export declare const getSSRStyles: () => Promise<Record<string, () => Promise<string[]>>>;
-export declare const getEntryIds: () => Promise<string[]>;
diff --git a/dist/core/runtime/nitro/utils/renderer/build-files.js b/dist/core/runtime/nitro/utils/renderer/build-files.js
index 2e2d743ae8da866f782601c4d0c2c00b858c8f74..cc274d8aed0a29814777daab25c90abe13434b49 100644
--- a/dist/core/runtime/nitro/utils/renderer/build-files.js
+++ b/dist/core/runtime/nitro/utils/renderer/build-files.js
@@ -8,23 +8,22 @@ import { appRootAttrs, appRootTag, appSpaLoaderAttrs, appSpaLoaderTag, spaLoadin
 import { buildAssetsURL } from "#internal/nuxt/paths";
 const APP_ROOT_OPEN_TAG = `<${appRootTag}${propsToString(appRootAttrs)}>`;
 const APP_ROOT_CLOSE_TAG = `</${appRootTag}>`;
-const getServerEntry = () => import("#build/dist/server/server.mjs").then((r) => r.default || r);
+export const getServerEntry = () => import("#build/dist/server/server.mjs").then((r) => r.default || r);
+export const getComponentsIslands = () => import("#build/dist/server/components.islands.mjs").then((r) => import.meta.dev ? r.default() : r);
 const getClientManifest = () => import("#build/dist/server/client.manifest.mjs").then((r) => r.default || r).then((r) => typeof r === "function" ? r() : r);
+const getPrecomputedDependencies = () => import("#build/dist/server/client.precomputed.mjs").then((r) => r.default || r).then((r) => typeof r === "function" ? r() : r);
 export const getSSRRenderer = lazyCachedFunction(async () => {
-  const manifest = await getClientManifest();
-  if (!manifest) {
-    throw new Error("client.manifest is not available");
-  }
   const createSSRApp = await getServerEntry();
   if (!createSSRApp) {
     throw new Error("Server bundle is not available");
   }
-  const options = {
-    manifest,
+  const precomputed = import.meta.dev ? void 0 : await getPrecomputedDependencies();
+  const renderer = createRenderer(createSSRApp, {
+    precomputed,
+    manifest: import.meta.dev ? await getClientManifest() : void 0,
     renderToString,
     buildAssetsURL
-  };
-  const renderer = createRenderer(createSSRApp, options);
+  });
   async function renderToString(input, context) {
     const html = await _renderToString(input, context);
     if (import.meta.dev && process.env.NUXT_VITE_NODE_OPTIONS) {
@@ -35,7 +34,7 @@ export const getSSRRenderer = lazyCachedFunction(async () => {
   return renderer;
 });
 const getSPARenderer = lazyCachedFunction(async () => {
-  const manifest = await getClientManifest();
+  const precomputed = import.meta.dev ? void 0 : await getPrecomputedDependencies();
   const spaTemplate = await import("#spa-template").then((r) => r.template).catch(() => "").then((r) => {
     if (spaLoadingTemplateOutside) {
       const APP_SPA_LOADER_OPEN_TAG = `<${appSpaLoaderTag}${propsToString(appSpaLoaderAttrs)}>`;
@@ -47,13 +46,13 @@ const getSPARenderer = lazyCachedFunction(async () => {
       return APP_ROOT_OPEN_TAG + r + APP_ROOT_CLOSE_TAG;
     }
   });
-  const options = {
-    manifest,
+  const renderer = createRenderer(() => () => {
+  }, {
+    precomputed,
+    manifest: import.meta.dev ? await getClientManifest() : void 0,
     renderToString: () => spaTemplate,
     buildAssetsURL
-  };
-  const renderer = createRenderer(() => () => {
-  }, options);
+  });
   const result = await renderer.renderToString({});
   const renderToString = (ssrContext) => {
     const config = useRuntimeConfig(ssrContext.event);
@@ -86,12 +85,3 @@ export function getRenderer(ssrContext) {
   return process.env.NUXT_NO_SSR || ssrContext.noSSR ? getSPARenderer() : getSSRRenderer();
 }
 export const getSSRStyles = lazyCachedFunction(() => import("#build/dist/server/styles.mjs").then((r) => r.default || r));
-export const getEntryIds = () => getClientManifest().then((r) => {
-  const entryIds = [];
-  for (const entry of Object.values(r)) {
-    if (entry._globalCSS) {
-      entryIds.push(entry.src);
-    }
-  }
-  return entryIds;
-});
diff --git a/dist/core/runtime/nitro/utils/renderer/islands.d.ts b/dist/core/runtime/nitro/utils/renderer/islands.d.ts
index bd881c1d4120c2555cc7c07178e7dc0328647138..2dece41cd51f289983bd22a57a3817c1b19e359e 100644
--- a/dist/core/runtime/nitro/utils/renderer/islands.d.ts
+++ b/dist/core/runtime/nitro/utils/renderer/islands.d.ts
@@ -1,13 +1,4 @@
 import type { SerializableHead } from '@unhead/vue/types';
-import type { NuxtSSRContext } from '#app/nuxt';
-/**
- * remove the root node from the html body
- */
-export declare function getServerComponentHTML(body: string): string;
-export declare function getSlotIslandResponse(ssrContext: NuxtSSRContext): NuxtIslandResponse['slots'];
-export declare function getClientIslandResponse(ssrContext: NuxtSSRContext): NuxtIslandResponse['components'];
-export declare function getComponentSlotTeleport(clientUid: string, teleports: Record<string, string>): Record<string, string>;
-export declare function replaceIslandTeleports(ssrContext: NuxtSSRContext, html: string): string;
 export interface NuxtIslandSlotResponse {
     props: Array<unknown>;
     fallback?: string;
@@ -22,11 +13,8 @@ export interface NuxtIslandContext {
 }
 export interface NuxtIslandResponse {
     id?: string;
-    html: string;
     head: SerializableHead;
-    props?: Record<string, Record<string, any>>;
-    components?: Record<string, NuxtIslandClientResponse>;
-    slots?: Record<string, NuxtIslandSlotResponse>;
+    ast: any;
 }
 export interface NuxtIslandClientResponse {
     html: string;
diff --git a/dist/core/runtime/nitro/utils/renderer/islands.js b/dist/core/runtime/nitro/utils/renderer/islands.js
index 9d3a049702291c09150ca9c187a3b6a1aef5988e..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 100644
--- a/dist/core/runtime/nitro/utils/renderer/islands.js
+++ b/dist/core/runtime/nitro/utils/renderer/islands.js
@@ -1,82 +0,0 @@
-import { appRootTag } from "#internal/nuxt.config.mjs";
-const ROOT_NODE_REGEX = new RegExp(`^<${appRootTag}[^>]*>([\\s\\S]*)<\\/${appRootTag}>$`);
-export function getServerComponentHTML(body) {
-  const match = body.match(ROOT_NODE_REGEX);
-  return match?.[1] || body;
-}
-const SSR_SLOT_TELEPORT_MARKER = /^uid=([^;]*);slot=(.*)$/;
-const SSR_CLIENT_TELEPORT_MARKER = /^uid=([^;]*);client=(.*)$/;
-const SSR_CLIENT_SLOT_MARKER = /^island-slot=([^;]*);(.*)$/;
-export function getSlotIslandResponse(ssrContext) {
-  if (!ssrContext.islandContext || !Object.keys(ssrContext.islandContext.slots).length) {
-    return void 0;
-  }
-  const response = {};
-  for (const [name, slot] of Object.entries(ssrContext.islandContext.slots)) {
-    response[name] = {
-      ...slot,
-      fallback: ssrContext.teleports?.[`island-fallback=${name}`]
-    };
-  }
-  return response;
-}
-export function getClientIslandResponse(ssrContext) {
-  if (!ssrContext.islandContext || !Object.keys(ssrContext.islandContext.components).length) {
-    return void 0;
-  }
-  const response = {};
-  for (const [clientUid, component] of Object.entries(ssrContext.islandContext.components)) {
-    const html = ssrContext.teleports?.[clientUid]?.replaceAll("<!--teleport start anchor-->", "") || "";
-    response[clientUid] = {
-      ...component,
-      html,
-      slots: getComponentSlotTeleport(clientUid, ssrContext.teleports ?? {})
-    };
-  }
-  return response;
-}
-export function getComponentSlotTeleport(clientUid, teleports) {
-  const entries = Object.entries(teleports);
-  const slots = {};
-  for (const [key, value] of entries) {
-    const match = key.match(SSR_CLIENT_SLOT_MARKER);
-    if (match) {
-      const [, id, slot] = match;
-      if (!slot || clientUid !== id) {
-        continue;
-      }
-      slots[slot] = value;
-    }
-  }
-  return slots;
-}
-export function replaceIslandTeleports(ssrContext, html) {
-  const { teleports, islandContext } = ssrContext;
-  if (islandContext || !teleports) {
-    return html;
-  }
-  for (const key in teleports) {
-    const matchClientComp = key.match(SSR_CLIENT_TELEPORT_MARKER);
-    if (matchClientComp) {
-      const [, uid, clientId] = matchClientComp;
-      if (!uid || !clientId) {
-        continue;
-      }
-      html = html.replace(new RegExp(` data-island-uid="${uid}" data-island-component="${clientId}"[^>]*>`), (full) => {
-        return full + teleports[key];
-      });
-      continue;
-    }
-    const matchSlot = key.match(SSR_SLOT_TELEPORT_MARKER);
-    if (matchSlot) {
-      const [, uid, slot] = matchSlot;
-      if (!uid || !slot) {
-        continue;
-      }
-      html = html.replace(new RegExp(` data-island-uid="${uid}" data-island-slot="${slot}"[^>]*>`), (full) => {
-        return full + teleports[key];
-      });
-    }
-  }
-  return html;
-}
diff --git a/dist/index.mjs b/dist/index.mjs
index 6f6d7012500f2ae604718d6d23f877e2ab8ca796..c75a177134c66da7af46a4ededf60b227403ceb3 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -5,7 +5,7 @@ import { AsyncLocalStorage } from 'node:async_hooks';
 import { dirname, resolve, normalize, basename, extname, relative, isAbsolute, join } from 'pathe';
 import { createHooks, createDebugger } from 'hookable';
 import ignore from 'ignore';
-import { useLogger, tryUseNuxt, useNuxt, directoryToURL, getLayerDirectories, resolveFiles, resolvePath, defineNuxtModule, findPath, addPlugin, addTemplate, addTypeTemplate, addComponent, useNitro, addBuildPlugin, isIgnored, resolveAlias as resolveAlias$1, addPluginTemplate, addImportsSources, addVitePlugin, createIsIgnored, updateTemplates, tryResolveModule, normalizeModuleTranspilePath, resolveNuxtModule, resolveIgnorePatterns, logger as logger$1, createResolver, importModule, tryImportModule, runWithNuxtContext, nuxtCtx, loadNuxtConfig, addWebpackPlugin, addServerPlugin, installModules, addServerTemplate, addServerHandler, addRouteMiddleware, resolveModuleWithOptions, normalizeTemplate, normalizePlugin } from '@nuxt/kit';
+import { useLogger, tryUseNuxt, useNuxt, directoryToURL, getLayerDirectories, resolveFiles, resolvePath, defineNuxtModule, findPath, addPlugin, addTemplate, addTypeTemplate, addComponent, useNitro, addBuildPlugin, isIgnored, resolveAlias as resolveAlias$1, addPluginTemplate, addImportsSources, createIsIgnored, updateTemplates, tryResolveModule, normalizeModuleTranspilePath, resolveNuxtModule, resolveIgnorePatterns, addVitePlugin, logger as logger$1, createResolver, importModule, tryImportModule, runWithNuxtContext, nuxtCtx, loadNuxtConfig, addWebpackPlugin, addServerPlugin, installModules, addServerTemplate, addServerHandler, addRouteMiddleware, resolveModuleWithOptions, normalizeTemplate, normalizePlugin } from '@nuxt/kit';
 import { resolvePackageJSON, readPackage, readPackageJSON } from 'pkg-types';
 import { hash, isEqual, serialize } from 'ohash';
 import consola, { consola as consola$1 } from 'consola';
@@ -19,28 +19,29 @@ import defu$1, { defu } from 'defu';
 import { satisfies, coerce } from 'semver';
 import { isCI, provider, isWindows, hasTTY } from 'std-env';
 import { genArrayFromRaw, genSafeVariableName, genImport, genDynamicImport, genObjectFromRawEntries, genString, genExport } from 'knitwork';
+import { resolveModulePath } from 'exsolve';
 import { addDependency } from 'nypm';
 import { reverseResolveAlias, filename, resolveAlias } from 'pathe/utils';
 import { createRoutesContext } from 'unplugin-vue-router';
 import { resolveOptions } from 'unplugin-vue-router/options';
 import { toRouteMatcher, createRouter, exportMatcher } from 'radix3';
 import { fileURLToPath, pathToFileURL } from 'node:url';
-import { resolveModulePath } from 'exsolve';
 import { runInNewContext } from 'node:vm';
 import { klona } from 'klona';
-import { parseAndWalk, ScopeTracker, walk, isBindingIdentifier, getUndeclaredIdentifiersInFunction } from 'oxc-walker';
+import { parseAndWalk as parseAndWalk$1, ScopeTracker as ScopeTracker$1, walk as walk$1, isBindingIdentifier, getUndeclaredIdentifiersInFunction } from 'oxc-walker';
 import { parseSync } from 'oxc-parser';
 import { transform } from 'oxc-transform';
 import { splitByCase, kebabCase, pascalCase, camelCase } from 'scule';
 import { createUnplugin } from 'unplugin';
 import { findStaticImports, findExports, parseStaticImport, parseNodeModulePath, lookupNodeModuleSubpath } from 'mlly';
 import MagicString from 'magic-string';
+import { stripLiteral } from 'strip-literal';
 import { unheadVueComposablesImports } from '@unhead/vue';
 import { defineUnimportPreset, createUnimport, toExports, scanDirExports } from 'unimport';
 import { glob } from 'tinyglobby';
-import { parse, walk as walk$1, ELEMENT_NODE } from 'ultrahtml';
 import { isObject } from '@vue/shared';
 import { parseQuery as parseQuery$1 } from 'vue-router';
+import { parse, walk as walk$2 } from 'ultrahtml';
 import { createTransformer } from 'unctx/transform';
 import { cpus } from 'node:os';
 import { createNitro, scanHandlers, writeTypes, copyPublicAssets, prepare, build as build$1, prerender, createDevServer } from 'nitropack';
@@ -406,7 +407,7 @@ function getRouteMeta(contents, absolutePath, extraExtractionKeys = /* @__PURE__
       continue;
     }
     const dynamicProperties = /* @__PURE__ */ new Set();
-    parseAndWalk(script.code, absolutePath.replace(/\.\w+$/, "." + script.loader), (node) => {
+    parseAndWalk$1(script.code, absolutePath.replace(/\.\w+$/, "." + script.loader), (node) => {
       if (node.type !== "ExpressionStatement" || node.expression.type !== "CallExpression" || node.expression.callee.type !== "Identifier") {
         return;
       }
@@ -943,7 +944,7 @@ const PageMetaPlugin = (options = {}) => createUnplugin(() => {
           }
         }
       }
-      const scopeTracker = new ScopeTracker({
+      const scopeTracker = new ScopeTracker$1({
         preserveExitedScopes: true
       });
       function processDeclaration(scopeTrackerNode) {
@@ -953,7 +954,7 @@ const PageMetaPlugin = (options = {}) => createUnplugin(() => {
             if (!decl.init) {
               continue;
             }
-            walk(decl.init, {
+            walk$1(decl.init, {
               enter: (node, parent) => {
                 if (node.type === "AwaitExpression") {
                   logger.error(`Await expressions are not supported in definePageMeta. File: '${id}'`);
@@ -981,7 +982,7 @@ const PageMetaPlugin = (options = {}) => createUnplugin(() => {
           }
         }
       }
-      const { program: ast } = parseAndWalk(code, id, {
+      const { program: ast } = parseAndWalk$1(code, id, {
         scopeTracker,
         parseOptions: {
           lang: query.lang ?? "ts"
@@ -989,7 +990,7 @@ const PageMetaPlugin = (options = {}) => createUnplugin(() => {
       });
       scopeTracker.freeze();
       let instances = 0;
-      walk(ast, {
+      walk$1(ast, {
         scopeTracker,
         enter: (node) => {
           if (node.type !== "CallExpression" || node.callee.type !== "Identifier") {
@@ -1025,7 +1026,7 @@ const PageMetaPlugin = (options = {}) => createUnplugin(() => {
             }
           }
           const definePageMetaScope = scopeTracker.getCurrentScope();
-          walk(meta, {
+          walk$1(meta, {
             scopeTracker,
             enter(node2, parent) {
               if (isBindingIdentifier(node2, parent) || node2.type !== "Identifier") {
@@ -1105,6 +1106,8 @@ function resolveEnd(node) {
   return "fnNode" in node ? node.fnNode.end : node.end;
 }
 
+const INJECTION_RE_TEMPLATE = /\b_ctx\.\$route\b/g;
+const INJECTION_RE_SCRIPT = /\bthis\.\$route\b/g;
 const INJECTION_SINGLE_RE = /\bthis\.\$route\b|\b_ctx\.\$route\b/;
 const RouteInjectionPlugin = (nuxt) => createUnplugin(() => {
   return {
@@ -1115,30 +1118,29 @@ const RouteInjectionPlugin = (nuxt) => createUnplugin(() => {
     },
     transform: {
       filter: {
-        code: {
-          include: INJECTION_SINGLE_RE,
-          exclude: [
-            `_ctx._.provides[__nuxt_route_symbol`,
-            "this._.provides[__nuxt_route_symbol"
-          ]
-        }
+        code: { include: INJECTION_SINGLE_RE }
       },
-      handler(code, id) {
+      handler(code) {
+        if (code.includes("_ctx._.provides[__nuxt_route_symbol") || code.includes("this._.provides[__nuxt_route_symbol")) {
+          return;
+        }
+        let replaced = false;
         const s = new MagicString(code);
-        parseAndWalk(code, id, (node) => {
-          if (node.type !== "MemberExpression") {
-            return;
-          }
-          if (node.object.type === "ThisExpression" && node.property.type === "Identifier" && node.property.name === "$route") {
-            s.overwrite(node.start, node.end, "(this._.provides[__nuxt_route_symbol] || this.$route)");
-            return;
-          }
-          if (node.object.type === "Identifier" && node.object.name === "_ctx" && node.property.type === "Identifier" && node.property.name === "$route") {
-            s.overwrite(node.start, node.end, "(_ctx._.provides[__nuxt_route_symbol] || _ctx.$route)");
+        const strippedCode = stripLiteral(code);
+        const replaceMatches = (regExp, replacement) => {
+          for (const match of strippedCode.matchAll(regExp)) {
+            const start = match.index;
+            const end = start + match[0].length;
+            s.overwrite(start, end, replacement);
+            replaced ||= true;
           }
-        });
-        if (s.hasChanged()) {
+        };
+        replaceMatches(INJECTION_RE_TEMPLATE, "(_ctx._.provides[__nuxt_route_symbol] || _ctx.$route)");
+        replaceMatches(INJECTION_RE_SCRIPT, "(this._.provides[__nuxt_route_symbol] || this.$route)");
+        if (replaced) {
           s.prepend("import { PageRouteSymbol as __nuxt_route_symbol } from '#app/components/injections';\n");
+        }
+        if (s.hasChanged()) {
           return {
             code: s.toString(),
             map: nuxt.options.sourcemap.client || nuxt.options.sourcemap.server ? s.generateMap({ hires: true }) : void 0
@@ -1737,7 +1739,7 @@ const UnheadImportsPlugin = (options) => createUnplugin(() => {
       handler(code, id) {
         const s = new MagicString(code);
         const importsToAdd = [];
-        parseAndWalk(code, id, function(node) {
+        parseAndWalk$1(code, id, function(node) {
           if (node.type === "ImportDeclaration" && [UnheadVue, "#app/composables/head"].includes(String(node.source.value))) {
             importsToAdd.push(...node.specifiers);
             const { start, end } = node;
@@ -2049,7 +2051,6 @@ const vuePreset = defineUnimportPreset({
     "hasInjectionContext",
     "nextTick",
     "provide",
-    "mergeModels",
     "toValue",
     "useModel",
     "useAttrs",
@@ -2182,7 +2183,7 @@ const componentsIslandsTemplate = {
       component.mode === "server" && !components.some((c) => c.pascalName === component.pascalName && c.mode === "client")
     );
     const pageExports = pages?.filter((p) => p.mode === "server" && p.file && p.name).map((p) => {
-      return `"page_${p.name}": defineAsyncComponent(${genDynamicImport(p.file)}.then(c => c.default || c))`;
+      return `"page_${p.name}": defineAsyncComponent(${genDynamicImport("virtual:vsc:" + p.file)}.then(c => c.default || c))`;
     }) || [];
     return [
       "import { defineAsyncComponent } from 'vue'",
@@ -2191,7 +2192,7 @@ const componentsIslandsTemplate = {
         (c) => {
           const exp = c.export === "default" ? "c.default || c" : `c['${c.export}']`;
           const comment = createImportMagicComments(c);
-          return `  "${c.pascalName}": defineAsyncComponent(${genDynamicImport(c.filePath, { comment })}.then(c => ${exp}))`;
+          return `  "${c.pascalName}": defineAsyncComponent(${genDynamicImport("virtual:vsc:" + c.filePath, { comment })}.then(c => ${exp}))`;
         }
       ).concat(pageExports).join(",\n"),
       "}"
@@ -2206,7 +2207,8 @@ function resolveComponentTypes(app, baseDir) {
     if (c.island) {
       continue;
     }
-    let type = `typeof ${genDynamicImport(isAbsolute(c.filePath) ? relative(baseDir, c.filePath).replace(NON_VUE_RE, "") : c.filePath.replace(NON_VUE_RE, ""), { wrapper: false })}['${c.export}']`;
+    const filePath = c.declarationPath || c.filePath;
+    let type = `typeof ${genDynamicImport(isAbsolute(filePath) ? relative(baseDir, filePath).replace(NON_VUE_RE, "") : filePath.replace(NON_VUE_RE, ""), { wrapper: false })}['${c.export}']`;
     if (c.mode === "server") {
       if (app.components.some((other) => other.pascalName === c.pascalName && other.mode === "client")) {
         if (c.filePath.startsWith(serverPlaceholderPath)) {
@@ -2348,6 +2350,7 @@ async function scanComponents(dirs, srcDir) {
         preload: Boolean(dir.preload),
         // specific to the file
         filePath,
+        declarationPath: filePath,
         pascalName,
         kebabName,
         chunkName,
@@ -2536,222 +2539,6 @@ function findComponent(components, name, mode) {
   return otherModeComponent;
 }
 
-const SCRIPT_RE$2 = /<script[^>]*>/i;
-const SCRIPT_RE_GLOBAL = /<script[^>]*>/gi;
-const HAS_SLOT_OR_CLIENT_RE = /<slot[^>]*>|nuxt-client/;
-const TEMPLATE_RE$1 = /<template>[\s\S]*<\/template>/;
-const NUXTCLIENT_ATTR_RE = /\s:?nuxt-client(?:="[^"]*")?/g;
-const IMPORT_CODE = "\nimport { mergeProps as __mergeProps } from 'vue'\nimport { vforToArray as __vforToArray } from '#app/components/utils'\nimport NuxtTeleportIslandComponent from '#app/components/nuxt-teleport-island-component'\nimport NuxtTeleportSsrSlot from '#app/components/nuxt-teleport-island-slot'";
-const EXTRACTED_ATTRS_RE = /v-(?:if|else-if|else)(?:="[^"]*")?/g;
-const KEY_RE = /:?key="[^"]"/g;
-function wrapWithVForDiv(code, vfor) {
-  return `<div v-for="${vfor}" style="display: contents;">${code}</div>`;
-}
-const IslandsTransformPlugin = (options) => createUnplugin((_options, meta) => {
-  const isVite = meta.framework === "vite";
-  return {
-    name: "nuxt:server-only-component-transform",
-    enforce: "pre",
-    transformInclude(id) {
-      if (!isVue(id)) {
-        return false;
-      }
-      if (isVite && options.selectiveClient === "deep") {
-        return true;
-      }
-      const components = options.getComponents();
-      const islands = components.filter(
-        (component) => component.island || component.mode === "server" && !components.some((c) => c.pascalName === component.pascalName && c.mode === "client")
-      );
-      const { pathname } = parseURL(decodeURIComponent(pathToFileURL(id).href));
-      return islands.some((c) => c.filePath === pathname);
-    },
-    transform: {
-      filter: {
-        code: {
-          include: [HAS_SLOT_OR_CLIENT_RE]
-        }
-      },
-      async handler(code, id) {
-        const template = code.match(TEMPLATE_RE$1);
-        if (!template) {
-          return;
-        }
-        const startingIndex = template.index || 0;
-        const s = new MagicString(code);
-        if (!SCRIPT_RE$2.test(code)) {
-          s.prepend("<script setup>" + IMPORT_CODE + "<\/script>");
-        } else {
-          s.replace(SCRIPT_RE_GLOBAL, (full) => {
-            return full + IMPORT_CODE;
-          });
-        }
-        let hasNuxtClient = false;
-        const ast = parse(template[0]);
-        await walk$1(ast, (node) => {
-          if (node.type !== ELEMENT_NODE) {
-            return;
-          }
-          if (node.name === "slot") {
-            const { attributes: attributes2, children, loc: loc2 } = node;
-            const slotName = attributes2.name ?? "default";
-            if (attributes2.name) {
-              delete attributes2.name;
-            }
-            if (attributes2["v-bind"]) {
-              attributes2._bind = extractAttributes(attributes2, ["v-bind"])["v-bind"];
-            }
-            const teleportAttributes = extractAttributes(attributes2, ["v-if", "v-else-if", "v-else"]);
-            const bindings = getPropsToString(attributes2);
-            s.appendLeft(startingIndex + loc2[0].start, `<NuxtTeleportSsrSlot${attributeToString(teleportAttributes)} name="${slotName}" :props="${bindings}">`);
-            if (children.length) {
-              const attrString = attributeToString(attributes2);
-              const slice = code.slice(startingIndex + loc2[0].end, startingIndex + loc2[1].start).replaceAll(KEY_RE, "");
-              s.overwrite(startingIndex + loc2[0].start, startingIndex + loc2[1].end, `<slot${attrString.replaceAll(EXTRACTED_ATTRS_RE, "")}/><template #fallback>${attributes2["v-for"] ? wrapWithVForDiv(slice, attributes2["v-for"]) : slice}</template>`);
-            } else {
-              s.overwrite(startingIndex + loc2[0].start, startingIndex + loc2[0].end, code.slice(startingIndex + loc2[0].start, startingIndex + loc2[0].end).replaceAll(EXTRACTED_ATTRS_RE, ""));
-            }
-            s.appendRight(startingIndex + loc2[1].end, "</NuxtTeleportSsrSlot>");
-            return;
-          }
-          if (!("nuxt-client" in node.attributes) && !(":nuxt-client" in node.attributes)) {
-            return;
-          }
-          hasNuxtClient = true;
-          if (!isVite || !options.selectiveClient) {
-            return;
-          }
-          const { loc, attributes } = node;
-          const attributeValue = attributes[":nuxt-client"] || attributes["nuxt-client"] || "true";
-          const wrapperAttributes = extractAttributes(attributes, ["v-if", "v-else-if", "v-else"]);
-          let startTag = code.slice(startingIndex + loc[0].start, startingIndex + loc[0].end).replace(NUXTCLIENT_ATTR_RE, "");
-          if (wrapperAttributes) {
-            startTag = startTag.replaceAll(EXTRACTED_ATTRS_RE, "");
-          }
-          s.appendLeft(startingIndex + loc[0].start, `<NuxtTeleportIslandComponent${attributeToString(wrapperAttributes)} :nuxt-client="${attributeValue}">`);
-          s.overwrite(startingIndex + loc[0].start, startingIndex + loc[0].end, startTag);
-          s.appendRight(startingIndex + loc[1].end, "</NuxtTeleportIslandComponent>");
-        });
-        if (hasNuxtClient) {
-          if (!options.selectiveClient) {
-            console.warn(`The \`nuxt-client\` attribute and client components within islands are only supported when \`experimental.componentIslands.selectiveClient\` is enabled. file: ${id}`);
-          } else if (!isVite) {
-            console.warn(`The \`nuxt-client\` attribute and client components within islands are only supported with Vite. file: ${id}`);
-          }
-        }
-        if (s.hasChanged()) {
-          return {
-            code: s.toString(),
-            map: s.generateMap({ source: id, includeContent: true })
-          };
-        }
-      }
-    }
-  };
-});
-function extractAttributes(attributes, names) {
-  const extracted = {};
-  for (const name of names) {
-    if (name in attributes) {
-      extracted[name] = attributes[name];
-      delete attributes[name];
-    }
-  }
-  return extracted;
-}
-function attributeToString(attributes) {
-  return Object.entries(attributes).map(([name, value]) => value ? ` ${name}="${value}"` : ` ${name}`).join("");
-}
-function isBinding(attr) {
-  return attr.startsWith(":");
-}
-function getPropsToString(bindings) {
-  const vfor = bindings["v-for"]?.split(" in ").map((v) => v.trim());
-  if (Object.keys(bindings).length === 0) {
-    return "undefined";
-  }
-  const contentParts = [];
-  for (const [name, value] of Object.entries(bindings)) {
-    if (name && (name !== "_bind" && name !== "v-for")) {
-      contentParts.push(isBinding(name) ? `[\`${name.slice(1)}\`]: ${value}` : `[\`${name}\`]: \`${value}\``);
-    }
-  }
-  const content = contentParts.join(",");
-  const data = bindings._bind ? `__mergeProps(${bindings._bind}, { ${content} })` : `{ ${content} }`;
-  if (!vfor) {
-    return `[${data}]`;
-  } else {
-    return `__vforToArray(${vfor[1]}).map(${vfor[0]} => (${data}))`;
-  }
-}
-const COMPONENT_CHUNK_ID = `#build/component-chunk`;
-const COMPONENT_CHUNK_RESOLVED_ID = "\0nuxt-component-chunk";
-const ComponentsChunkPlugin = (options) => {
-  const chunkIds = /* @__PURE__ */ new Map();
-  const paths = /* @__PURE__ */ new Map();
-  return [
-    {
-      name: "nuxt:components-chunk:client",
-      apply: () => !options.dev,
-      applyToEnvironment: (environment) => environment.name === "client",
-      buildStart() {
-        for (const c of options.getComponents()) {
-          if (!c.filePath || c.mode === "server") {
-            continue;
-          }
-          chunkIds.set(c.pascalName, this.emitFile({
-            type: "chunk",
-            name: `${c.pascalName}-chunk.mjs`,
-            id: c.filePath,
-            preserveSignature: "strict"
-          }));
-        }
-      },
-      generateBundle(_, bundle) {
-        const ids = /* @__PURE__ */ new Set();
-        for (const [name, id] of chunkIds.entries()) {
-          const filename = this.getFileName(id);
-          ids.add(filename);
-          paths.set(name, filename);
-        }
-        for (const chunk of Object.values(bundle)) {
-          if (chunk.type === "chunk") {
-            if (ids.has(chunk.fileName)) {
-              chunk.isEntry = false;
-            }
-          }
-        }
-      }
-    },
-    {
-      name: "nuxt:components-chunk:server",
-      resolveId: {
-        order: "pre",
-        handler(id) {
-          if (id === COMPONENT_CHUNK_ID) {
-            return COMPONENT_CHUNK_RESOLVED_ID;
-          }
-        }
-      },
-      load(id) {
-        if (id === COMPONENT_CHUNK_RESOLVED_ID) {
-          if (options.dev) {
-            const filePaths = {};
-            for (const c of options.getComponents()) {
-              if (!c.filePath || c.mode === "server") {
-                continue;
-              }
-              filePaths[c.pascalName] = `@fs/${c.filePath}`;
-            }
-            return `export default ${genObjectFromRawEntries(Object.entries(filePaths).map(([name, path]) => [name, genString(path)]))}`;
-          }
-          return `export default ${genObjectFromRawEntries(Array.from(paths.entries()).map(([name, id2]) => [name, genString("/" + id2)]))}`;
-        }
-      }
-    }
-  ];
-};
-
 const COMPONENT_QUERY_RE = /[?&]nuxt_component=/;
 function TransformPlugin$1(nuxt, options) {
   const componentUnimport = createUnimport({
@@ -2887,7 +2674,7 @@ const TreeShakeTemplatePlugin = (options) => createUnplugin(() => {
         return;
       }
       const componentsToRemoveSet = /* @__PURE__ */ new Set();
-      const { program: ast } = parseAndWalk(code, id, (node) => {
+      const { program: ast } = parseAndWalk$1(code, id, (node) => {
         if (!isSsrRender(node)) {
           return;
         }
@@ -2906,7 +2693,7 @@ const TreeShakeTemplatePlugin = (options) => createUnplugin(() => {
             s.remove(slot.start, slot.end + 1);
             const removedCode = `({${code.slice(slot.start, slot.end + 1)}})`;
             const currentState = s.toString();
-            parseAndWalk(removedCode, id, (node2) => {
+            parseAndWalk$1(removedCode, id, (node2) => {
               if (!isSsrRender(node2)) {
                 return;
               }
@@ -2940,7 +2727,7 @@ const TreeShakeTemplatePlugin = (options) => createUnplugin(() => {
 });
 function removeFromSetupReturn(codeAst, name, magicString) {
   let walkedInSetup = false;
-  walk(codeAst, {
+  walk$1(codeAst, {
     enter(node) {
       if (walkedInSetup) {
         this.skip();
@@ -3000,9 +2787,9 @@ function isComponentNotCalledInSetup(code, id, name) {
     return;
   }
   let found = false;
-  parseAndWalk(code, id, function(node) {
+  parseAndWalk$1(code, id, function(node) {
     if (node.type === "Property" && node.key.type === "Identifier" && node.value.type === "FunctionExpression" && node.key.name === "setup" || node.type === "FunctionDeclaration" && (node.id?.name === "_sfc_ssrRender" || node.id?.name === "ssrRender")) {
-      walk(node, {
+      walk$1(node, {
         enter(node2) {
           if (found || node2.type === "VariableDeclaration") {
             this.skip();
@@ -3035,7 +2822,7 @@ function getComponentName(ssrRenderNode) {
   }
 }
 function removeVariableDeclarator(codeAst, name, magicString, removedNodes) {
-  walk(codeAst, {
+  walk$1(codeAst, {
     enter(node) {
       if (node.type !== "VariableDeclaration") {
         return;
@@ -3111,7 +2898,7 @@ const ComponentNamePlugin = (options) => createUnplugin(() => {
         const s = new MagicString(code);
         s.replace(NAME_RE, `__name: ${JSON.stringify(component.pascalName)}`);
         if (!s.hasChanged()) {
-          parseAndWalk(code, id, function(node) {
+          parseAndWalk$1(code, id, function(node) {
             if (node.type !== "ExportDefaultDeclaration") {
               return;
             }
@@ -3131,7 +2918,7 @@ const ComponentNamePlugin = (options) => createUnplugin(() => {
   };
 });
 
-const SCRIPT_RE$1 = /(?<=<script[^>]*>)[\s\S]*?(?=<\/script>)/gi;
+const SCRIPT_RE$2 = /(?<=<script[^>]*>)[\s\S]*?(?=<\/script>)/gi;
 const TEMPLATE_RE = /<template>([\s\S]*)<\/template>/;
 const hydrationStrategyMap = {
   hydrateOnIdle: "Idle",
@@ -3170,19 +2957,19 @@ const LazyHydrationTransformPlugin = (options) => createUnplugin(() => {
         }
         try {
           const ast = parse(template);
-          const scopeTracker = new ScopeTracker({ preserveExitedScopes: true });
-          for (const { 0: script } of code.matchAll(SCRIPT_RE$1)) {
+          const scopeTracker = new ScopeTracker$1({ preserveExitedScopes: true });
+          for (const { 0: script } of code.matchAll(SCRIPT_RE$2)) {
             if (!script) {
               continue;
             }
             try {
-              parseAndWalk(script, id, { scopeTracker });
+              parseAndWalk$1(script, id, { scopeTracker });
             } catch {
             }
           }
           const s = new MagicString(code);
           const components = new Set(options.getComponents().map((c) => c.pascalName));
-          await walk$1(ast, (node) => {
+          await walk$2(ast, (node) => {
             if (node.type !== 1) {
               return;
             }
@@ -3273,7 +3060,7 @@ const LazyHydrationMacroTransformPlugin = (options) => createUnplugin(() => {
         const s = new MagicString(code);
         const names = /* @__PURE__ */ new Set();
         const edits = [];
-        parseAndWalk(code, id, (node, parent) => {
+        parseAndWalk$1(code, id, (node, parent) => {
           if (node.type !== "CallExpression") {
             return;
           }
@@ -3532,32 +3319,7 @@ const componentsModule = defineNuxtModule({
       }));
       addImportsSources(lazyHydrationMacroPreset);
     }
-    if (nuxt.options.experimental.componentIslands) {
-      const selectiveClient = typeof nuxt.options.experimental.componentIslands === "object" && nuxt.options.experimental.componentIslands.selectiveClient;
-      addVitePlugin({
-        name: "nuxt-server-component-hmr",
-        handleHotUpdate(ctx) {
-          const components = getComponents();
-          const filePath = normalize(ctx.file);
-          const comp = components.find((c) => c.filePath === filePath);
-          if (comp?.mode === "server") {
-            ctx.server.ws.send({
-              event: `nuxt-server-component:${comp.pascalName}`,
-              type: "custom"
-            });
-          }
-        }
-      }, { server: false });
-      addBuildPlugin(IslandsTransformPlugin({ getComponents, selectiveClient }), { client: false, prepend: true });
-      if (selectiveClient && nuxt.options.builder === "@nuxt/vite-builder") {
-        addVitePlugin(() => ComponentsChunkPlugin({ dev: nuxt.options.dev, getComponents }));
-      } else {
-        addTemplate({
-          filename: "component-chunk.mjs",
-          getContents: () => `export default {}`
-        });
-      }
-    }
+    if (nuxt.options.experimental.componentIslands) ;
   }
 });
 function normalizeDirs(dir, cwd, options) {
@@ -3903,21 +3665,20 @@ const UnctxTransformPlugin = (options) => createUnplugin(() => {
 });
 
 const TreeShakeComposablesPlugin = (options) => createUnplugin(() => {
-  const allComposableNames = new Set(Object.values(options.composables).flat());
-  if (!allComposableNames.size) {
-    return [];
-  }
+  const composableNames = Object.values(options.composables).flat();
+  const regexp = `(^\\s*)(${composableNames.join("|")})(?=\\((?!\\) \\{))`;
+  const COMPOSABLE_RE = new RegExp(regexp, "m");
   return {
     name: "nuxt:tree-shake-composables:transform",
     enforce: "post",
-    transformInclude(id) {
-      return isVue(id, { type: ["script"] }) || isJS(id);
+    transformInclude(id2) {
+      return isVue(id2, { type: ["script"] }) || isJS(id2);
     },
     transform: {
       filter: {
-        code: { include: new RegExp(`\\b(?:${[...allComposableNames].map((r) => escapeRE(r)).join("|")})\\b`) }
+        code: { include: COMPOSABLE_RE }
       },
-      handler(code, id) {
+      handler(code) {
         const s = new MagicString(code);
         const scopeTracker = new ScopeTracker({ preserveExitedScopes: true });
         const parseResult = parseAndWalk(code, id, {
@@ -4206,7 +3967,8 @@ async function initNitro(nuxt) {
       "#internal/nuxt/app-config": () => nuxt.vfs["#build/app.config.mjs"]?.replace(/\/\*\* client \*\*\/[\s\S]*\/\*\* client-end \*\*\//, "") || "",
       "#spa-template": async () => `export const template = ${JSON.stringify(await spaLoadingTemplate(nuxt))}`,
       // this will be overridden in vite plugin
-      "#internal/entry-chunk.mjs": () => `export const entryFileName = undefined`
+      "#internal/entry-chunk.mjs": () => `export const entryFileName = undefined`,
+      "#internal/nuxt/entry-ids.mjs": () => `export default []`
     },
     routeRules: {
       "/__nuxt_error": { cache: false }
@@ -4280,7 +4042,21 @@ async function initNitro(nuxt) {
             }
             return targets;
           }, [])
-        ] : []
+        ] : [],
+        // todo fix 
+        ...[
+          ...nuxt.options.modulesDir.reduce((targets, path) => {
+            const serverRendererPath = resolve(path, "vue/index.mjs");
+            if (existsSync(serverRendererPath)) {
+              targets.push(serverRendererPath);
+            }
+            return targets;
+          }, [])
+        ]
+      ],
+      // todo this too...
+      external: [
+        "vue"
       ]
     },
     alias: {
@@ -4688,6 +4464,7 @@ async function initNitro(nuxt) {
         if (name === "server") {
           const memfs = compiler.outputFileSystem;
           nitro.options.virtual["#build/dist/server/server.mjs"] = () => memfs.readFileSync(join(nuxt.options.buildDir, "dist/server/server.mjs"), "utf-8");
+          nitro.options.virtual["#build/dist/server/components.islands.mjs"] = () => memfs.readFileSync(join(nuxt.options.buildDir, "dist/server/components.islands.mjs"), "utf-8");
         }
       });
       nuxt.hook(`${builder}:compiled`, () => {
@@ -4894,7 +4671,7 @@ function extractMetadata(code, loader = "ts") {
   if (/defineNuxtPlugin\s*\([\w(]/.test(code)) {
     return {};
   }
-  parseAndWalk(code, `file.${loader}`, (node) => {
+  parseAndWalk$1(code, `file.${loader}`, (node) => {
     if (node.type !== "CallExpression" || node.callee.type !== "Identifier") {
       return;
     }
@@ -4985,7 +4762,7 @@ const RemovePluginMetadataPlugin = (nuxt) => createUnplugin(() => {
       let wrapped = false;
       const wrapperNames = /* @__PURE__ */ new Set(["defineNuxtPlugin", "definePayloadPlugin"]);
       try {
-        parseAndWalk(code, id, (node) => {
+        parseAndWalk$1(code, id, (node) => {
           if (node.type === "ImportSpecifier" && node.imported.type === "Identifier" && (node.imported.name === "defineNuxtPlugin" || node.imported.name === "definePayloadPlugin")) {
             wrapperNames.add(node.local.name);
           }
@@ -5061,8 +4838,8 @@ const AsyncContextInjectionPlugin = (nuxt) => createUnplugin(() => {
 
 const stringTypes = ["Literal", "TemplateLiteral"];
 const NUXT_LIB_RE = /node_modules\/(?:nuxt|nuxt3|nuxt-nightly)\//;
-const SUPPORTED_EXT_RE = /\.(?:m?[jt]sx?|vue)/;
-const SCRIPT_RE = /(?<=<script[^>]*>)[\s\S]*?(?=<\/script>)/i;
+const SUPPORTED_EXT_RE$1 = /\.(?:m?[jt]sx?|vue)/;
+const SCRIPT_RE$1 = /(?<=<script[^>]*>)[\s\S]*?(?=<\/script>)/i;
 const ComposableKeysPlugin = (options) => createUnplugin(() => {
   const composableMeta = {};
   const composableLengths = /* @__PURE__ */ new Set();
@@ -5079,27 +4856,27 @@ const ComposableKeysPlugin = (options) => createUnplugin(() => {
     enforce: "post",
     transformInclude(id) {
       const { pathname, search } = parseURL(decodeURIComponent(pathToFileURL(id).href));
-      return !NUXT_LIB_RE.test(pathname) && SUPPORTED_EXT_RE.test(pathname) && parseQuery(search).type !== "style" && !parseQuery(search).macro;
+      return !NUXT_LIB_RE.test(pathname) && SUPPORTED_EXT_RE$1.test(pathname) && parseQuery(search).type !== "style" && !parseQuery(search).macro;
     },
     transform: {
       filter: {
         code: { include: KEYED_FUNCTIONS_RE }
       },
       handler(code, id) {
-        const { 0: script = code, index: codeIndex = 0 } = code.match(SCRIPT_RE) || { index: 0, 0: code };
+        const { 0: script = code, index: codeIndex = 0 } = code.match(SCRIPT_RE$1) || { index: 0, 0: code };
         const s = new MagicString(code);
         let imports;
         let count = 0;
         const relativeID = isAbsolute(id) ? relative(options.rootDir, id) : id;
         const { pathname: relativePathname } = parseURL(relativeID);
-        const scopeTracker = new ScopeTracker({
+        const scopeTracker = new ScopeTracker$1({
           preserveExitedScopes: true
         });
-        const parseResult = parseAndWalk(script, id, {
+        const parseResult = parseAndWalk$1(script, id, {
           scopeTracker
         });
         scopeTracker.freeze();
-        walk(parseResult.program, {
+        walk$1(parseResult.program, {
           scopeTracker,
           enter(node) {
             if (node.type !== "CallExpression" || node.callee.type !== "Identifier") {
@@ -5342,7 +5119,7 @@ function PrehydrateTransformPlugin(options = {}) {
       },
       handler(code, id) {
         const s = new MagicString(code);
-        parseAndWalk(code, id, (node) => {
+        parseAndWalk$1(code, id, (node) => {
           if (node.type !== "CallExpression" || node.callee.type !== "Identifier") {
             return;
           }
@@ -5379,6 +5156,140 @@ function PrehydrateTransformPlugin(options = {}) {
   }));
 }
 
+const functionsToExtract = /* @__PURE__ */ new Set(["useAsyncData", "useLazyAsyncData"]);
+const FUNCTIONS_RE = /\buse(?:Lazy)?AsyncData\b/;
+const SUPPORTED_EXT_RE = /\.(?:m?[jt]sx?|vue)$/;
+const SCRIPT_RE = /(?<=<script[^>]*>)[\s\S]*?(?=<\/script>)/i;
+const ExtractAsyncDataHandlersPlugin = (options) => createUnplugin(() => {
+  const asyncDatas = {};
+  let count = 0;
+  return {
+    name: "nuxt:extract-async-data-handlers",
+    enforce: "post",
+    resolveId(source) {
+      if (source in asyncDatas) {
+        return source;
+      }
+    },
+    load(id) {
+      if (id in asyncDatas) {
+        return asyncDatas[id];
+      }
+    },
+    transformInclude(id) {
+      const { pathname, search } = parseURL(decodeURIComponent(pathToFileURL(id).href));
+      return SUPPORTED_EXT_RE.test(pathname) && parseQuery(search).type !== "style" && !parseQuery(search).macro;
+    },
+    transform: {
+      filter: {
+        id: {
+          exclude: [/nuxt\/(src|dist)\/app/]
+        },
+        code: { include: FUNCTIONS_RE }
+      },
+      handler(code, id) {
+        const { 0: script = code, index: codeIndex = 0 } = code.match(SCRIPT_RE) || { index: 0, 0: code };
+        let s;
+        const scopeTracker = new ScopeTracker$1({ preserveExitedScopes: true });
+        const parseResult = parseAndWalk$1(script, id, { scopeTracker });
+        scopeTracker.freeze();
+        walk$1(parseResult.program, {
+          scopeTracker,
+          enter(node) {
+            if (node.type !== "CallExpression" || node.callee.type !== "Identifier" || !functionsToExtract.has(node.callee.name)) {
+              return;
+            }
+            const callExpression = node;
+            const fetcherFunction = callExpression.arguments.find((fn) => fn.type === "ArrowFunctionExpression" || fn.type === "FunctionExpression");
+            if (!fetcherFunction || fetcherFunction.type !== "ArrowFunctionExpression" && fetcherFunction.type !== "FunctionExpression" || !fetcherFunction.body) {
+              return;
+            }
+            s ||= new MagicString(code);
+            const referencedVariables = /* @__PURE__ */ new Set();
+            const imports = /* @__PURE__ */ new Set();
+            walk$1(fetcherFunction.body, {
+              scopeTracker,
+              enter(innerNode, parent) {
+                if (innerNode.type !== "Identifier") {
+                  return;
+                }
+                if (parent) {
+                  if (parent.type === "MemberExpression" && parent.property === innerNode && parent.computed === false) {
+                    return;
+                  }
+                  if (parent.type === "Property" && parent.key === innerNode && parent.computed === false) {
+                    return;
+                  }
+                  if (parent.type === "MethodDefinition" && parent.key === innerNode && parent.computed === false) {
+                    return;
+                  }
+                  if (parent.type === "PropertyDefinition" && parent.key === innerNode && parent.computed === false) {
+                    return;
+                  }
+                }
+                const declaration = scopeTracker.getDeclaration(innerNode.name);
+                if (!declaration) {
+                  return;
+                }
+                if (declaration.type === "Import") {
+                  imports.add(innerNode.name);
+                } else if (declaration.type !== "FunctionParam") {
+                  const functionBodyStart = fetcherFunction.body.start;
+                  const functionBodyEnd = fetcherFunction.body.end;
+                  if (declaration.start < functionBodyStart || declaration.end > functionBodyEnd) {
+                    referencedVariables.add(innerNode.name);
+                  }
+                }
+              }
+            });
+            const importStatements = /* @__PURE__ */ new Set();
+            walk$1(parseResult.program, {
+              enter(importDecl) {
+                if (importDecl.type !== "ImportDeclaration") {
+                  return;
+                }
+                if (importDecl.specifiers?.some((spec) => spec.local && imports.has(spec.local.name))) {
+                  importStatements.add(script.slice(importDecl.start, importDecl.end));
+                }
+              }
+            });
+            const imps = Array.from(importStatements).join("\n");
+            const key = `${dirname(id)}/async-data-chunk-${count++}.js`;
+            const isBlockStatement = fetcherFunction.body.type === "BlockStatement";
+            const startOffset = codeIndex + fetcherFunction.body.start;
+            const endOffset = codeIndex + fetcherFunction.body.end;
+            const chunk = s.clone();
+            const parameters = [...referencedVariables].join(", ");
+            const returnPrefix = isBlockStatement ? "" : "return ";
+            const preface = `${imps}
+export default async function (${parameters}) { ${returnPrefix}`;
+            const suffix = ` }`;
+            if (isBlockStatement) {
+              chunk.overwrite(0, startOffset + 1, preface);
+              chunk.overwrite(endOffset - 1, code.length, suffix);
+            } else {
+              chunk.overwrite(0, startOffset, preface);
+              chunk.overwrite(endOffset, code.length, suffix);
+            }
+            asyncDatas[key] = {
+              code: chunk.toString(),
+              map: options.sourcemap ? chunk.generateMap({ hires: true }) : void 0
+            };
+            const importCall = `() => import('${key}').then(r => (r.default || r)(${parameters}))`;
+            s.overwrite(codeIndex + fetcherFunction.start, codeIndex + fetcherFunction.end, importCall);
+          }
+        });
+        if (s?.hasChanged()) {
+          return {
+            code: s.toString(),
+            map: options.sourcemap ? s.generateMap({ hires: true }) : void 0
+          };
+        }
+      }
+    }
+  };
+});
+
 const PREFIX = "virtual:nuxt:";
 const PREFIX_RE = /^\/?virtual:nuxt:/;
 const RELATIVE_ID_RE = /^\.{1,2}[\\/]/;
@@ -5608,6 +5519,10 @@ Using \`${fallbackCompatibilityDate}\` as fallback. More info at: ${colors.under
     opts.nodeReferences.push({ path: resolve(nuxt.options.buildDir, "types/runtime-config.d.ts") });
     opts.nodeReferences.push({ path: resolve(nuxt.options.buildDir, "types/app.config.d.ts") });
     opts.nodeReferences.push({ types: "nuxt" });
+    opts.nodeReferences.push({ types: relative(nuxt.options.buildDir, resolveModulePath("@nuxt/vite-builder", { from: import.meta.url })) });
+    if (typeof nuxt.options.builder === "string" && nuxt.options.builder !== "@nuxt/vite-builder") {
+      opts.nodeReferences.push({ types: nuxt.options.builder });
+    }
     opts.sharedReferences.push({ path: resolve(nuxt.options.buildDir, "types/runtime-config.d.ts") });
     opts.sharedReferences.push({ path: resolve(nuxt.options.buildDir, "types/app.config.d.ts") });
     paths ||= await resolveTypescriptPaths(nuxt);
@@ -5703,6 +5618,12 @@ Using \`${fallbackCompatibilityDate}\` as fallback. More info at: ${colors.under
     addBuildPlugin(DevOnlyPlugin({
       sourcemap: !!nuxt.options.sourcemap.server || !!nuxt.options.sourcemap.client
     }));
+    if (nuxt.options.experimental.extractAsyncDataHandlers) {
+      addBuildPlugin(ExtractAsyncDataHandlersPlugin({
+        sourcemap: !!nuxt.options.sourcemap.client,
+        rootDir: nuxt.options.rootDir
+      }), { server: false });
+    }
   }
   if (nuxt.options.dev) {
     addPlugin(resolve(nuxt.options.appDir, "plugins/check-if-layout-used"));
@@ -6040,6 +5961,9 @@ async function loadNuxt(opts) {
   if (options.telemetry !== false && !process.env.NUXT_TELEMETRY_DISABLED) {
     options._modules.push("@nuxt/telemetry");
   }
+  if (options.experimental.typescriptPlugin) {
+    options._modules.push("@dxup/nuxt");
+  }
   const allowedKeys = /* @__PURE__ */ new Set(["baseURL", "buildAssetsDir", "cdnURL", "buildId"]);
   for (const key in options.runtimeConfig.app) {
     if (!allowedKeys.has(key)) {
@@ -6211,7 +6135,7 @@ const rootComponentTemplate = {
   filename: "root-component.mjs",
   // TODO: fix upstream in vite - this ensures that vite generates a module graph for islands
   // but should not be necessary (and has a warmup performance cost). See https://github.com/nuxt/nuxt/pull/24584.
-  getContents: (ctx) => (ctx.nuxt.options.dev ? "import '#build/components.islands.mjs';\n" : "") + genExport(ctx.app.rootComponent, ["default"])
+  getContents: (ctx) => genExport(ctx.app.rootComponent, ["default"])
 };
 const errorComponentTemplate = {
   filename: "error-component.mjs",
diff --git a/package.json b/package.json
index 148fa513fc09a47b50bceb3330237bb493f37c6b..84dd9fa3c334c1e5a9a2daf7602c9dc69c02a9da 100644
--- a/package.json
+++ b/package.json
@@ -63,11 +63,19 @@
     "kit.*",
     "schema.*"
   ],
+  "scripts": {
+    "prepack": "unbuild",
+    "test:attw": "attw --pack"
+  },
   "dependencies": {
-    "@nuxt/cli": "^3.29.0",
+    "@dxup/nuxt": "^0.1.0",
+    "@nuxt/cli": "^3.29.3",
     "@nuxt/devalue": "^2.0.2",
     "@nuxt/devtools": "^2.6.5",
+    "@nuxt/kit": "workspace:*",
+    "@nuxt/schema": "workspace:*",
     "@nuxt/telemetry": "^2.6.6",
+    "@nuxt/vite-builder": "workspace:*",
     "@unhead/vue": "^2.0.14",
     "@vue/shared": "^3.5.22",
     "c12": "^3.3.0",
@@ -94,7 +102,7 @@
     "mlly": "^1.8.0",
     "mocked-exports": "^0.1.1",
     "nanotar": "^0.2.0",
-    "nitropack": "^2.12.6",
+    "nitropack": "^2.12.7",
     "nypm": "^0.6.2",
     "ofetch": "^1.4.1",
     "ohash": "^2.0.11",
@@ -108,8 +116,10 @@
     "pkg-types": "^2.3.0",
     "radix3": "^1.1.2",
     "scule": "^1.3.0",
-    "semver": "^7.7.2",
+    "semver": "^7.7.3",
+    "seroval": "^1.3.2",
     "std-env": "^3.9.0",
+    "strip-literal": "^3.1.0",
     "tinyglobby": "^0.2.15",
     "ufo": "^1.6.1",
     "ultrahtml": "^1.6.0",
@@ -123,10 +133,8 @@
     "vue": "^3.5.22",
     "vue-bundle-renderer": "^2.2.0",
     "vue-devtools-stub": "^0.1.0",
-    "vue-router": "^4.5.1",
-    "@nuxt/schema": "4.1.3",
-    "@nuxt/kit": "4.1.3",
-    "@nuxt/vite-builder": "4.1.3"
+    "vue-onigiri": "^0.2.0",
+    "vue-router": "^4.5.1"
   },
   "devDependencies": {
     "@nuxt/scripts": "0.12.1",
@@ -154,8 +162,5 @@
   },
   "engines": {
     "node": "^20.19.0 || >=22.12.0"
-  },
-  "scripts": {
-    "test:attw": "attw --pack"
   }
 }
