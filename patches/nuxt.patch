diff --git a/dist/app/compat/interval.d.ts b/dist/app/compat/interval.d.ts
index 9c88d28c5ee24c46b4b23354106a16c2764b2c13..b9909ed310e782fb871a58845d12f7b291b15b2c 100644
--- a/dist/app/compat/interval.d.ts
+++ b/dist/app/compat/interval.d.ts
@@ -1 +1 @@
-export declare const setInterval: (((handler: TimerHandler, timeout?: number, ...arguments: any[]) => number) & typeof globalThis.setInterval) | (() => void);
+export declare const setInterval: typeof globalThis.setInterval | (() => void);
diff --git a/dist/app/compat/interval.js b/dist/app/compat/interval.js
index 484356f26e0df2a4a55dddc9e9a3873b80b36837..93d0da41f95a97b4d5456a010e4c0dc2a991416f 100644
--- a/dist/app/compat/interval.js
+++ b/dist/app/compat/interval.js
@@ -1,6 +1,6 @@
 import { createError } from "../composables/error.js";
 const intervalError = "[nuxt] `setInterval` should not be used on the server. Consider wrapping it with an `onNuxtReady`, `onBeforeMount` or `onMounted` lifecycle hook, or ensure you only call it in the browser by checking `import.meta.client`.";
-export const setInterval = import.meta.client ? window.setInterval : () => {
+export const setInterval = import.meta.client ? globalThis.setInterval : () => {
   if (import.meta.dev) {
     throw createError({
       statusCode: 500,
diff --git a/dist/app/components/client-only.d.ts b/dist/app/components/client-only.d.ts
index 57cc2c294e911310f97b73ee4a788d692653890a..67897283994572f9335730fd359c60a0bd353a88 100644
--- a/dist/app/components/client-only.d.ts
+++ b/dist/app/components/client-only.d.ts
@@ -1,13 +1,13 @@
-import type { ComponentOptions, InjectionKey, SlotsType, VNode } from 'vue';
+import type { ComponentOptions, InjectionKey, RendererNode, SlotsType, VNode } from 'vue';
 export declare const clientOnlySymbol: InjectionKey<boolean>;
 declare const _default: import("vue").DefineComponent<{
     placeholder?: any;
     fallback?: any;
     placeholderTag?: any;
     fallbackTag?: any;
-}, () => VNode<import("vue").RendererNode, import("vue").RendererElement, {
+}, () => VNode<RendererNode, import("vue").RendererElement, {
     [key: string]: any;
-}> | VNode<import("vue").RendererNode, import("vue").RendererElement, {
+}> | VNode<RendererNode, import("vue").RendererElement, {
     [key: string]: any;
 }>[] | undefined, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<{
     placeholder?: any;
@@ -24,3 +24,5 @@ declare const _default: import("vue").DefineComponent<{
 }>, {}, {}, string, import("vue").ComponentProvideOptions, true, {}, any>;
 export default _default;
 export declare function createClientOnly<T extends ComponentOptions>(component: T): any;
+export declare function isStartFragment(element: RendererNode): boolean;
+export declare function isEndFragment(element: RendererNode): boolean;
diff --git a/dist/app/components/client-only.js b/dist/app/components/client-only.js
index 19e76ad081b5ffe8aaa9cd073f8e8bab95d9ddeb..54a2141a77d02017ba8b8a562e2abcc4fb154bf0 100644
--- a/dist/app/components/client-only.js
+++ b/dist/app/components/client-only.js
@@ -1,8 +1,8 @@
-import { cloneVNode, createElementBlock, defineComponent, getCurrentInstance, h, onMounted, provide, shallowRef } from "vue";
+import { cloneVNode, createElementBlock, createStaticVNode, defineComponent, getCurrentInstance, h, onMounted, provide, shallowRef } from "vue";
 import { isPromise } from "@vue/shared";
 import { useNuxtApp } from "../nuxt.js";
 import ServerPlaceholder from "./server-placeholder.js";
-import { elToStaticVNode } from "./utils.js";
+import { getFragmentHTML } from "./utils.js";
 export const clientOnlySymbol = Symbol.for("nuxt:client-only");
 const STATIC_DIV = "<div></div>";
 export default defineComponent({
@@ -128,3 +128,16 @@ function extractDirectives(instance) {
   instance.vnode.dirs = null;
   return directives;
 }
+function elToStaticVNode(el, staticNodeFallback) {
+  const fragment = el ? getFragmentHTML(el) : staticNodeFallback ? [staticNodeFallback] : void 0;
+  if (fragment) {
+    return createStaticVNode(fragment.join(""), fragment.length);
+  }
+  return h("div");
+}
+export function isStartFragment(element) {
+  return element.nodeName === "#comment" && element.nodeValue === "[";
+}
+export function isEndFragment(element) {
+  return element.nodeName === "#comment" && element.nodeValue === "]";
+}
diff --git a/dist/app/components/error-404.vue b/dist/app/components/error-404.vue
index f7de60ee125295a395374c1ec9e022d7a33d4943..4ec8838deaebc9fad570b1ccef7c87cee9f4ea17 100644
--- a/dist/app/components/error-404.vue
+++ b/dist/app/components/error-404.vue
@@ -26,7 +26,7 @@ useHead({
   title: `${props.statusCode} - ${props.statusMessage} | ${props.appName}`,
   script: [
     {
-      innerHTML: `!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)}).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();`
+      innerHTML: `!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver((e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)})).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();`
     }
   ],
   style: [
diff --git a/dist/app/components/error-500.vue b/dist/app/components/error-500.vue
index 701b21ad7c0310825552d62a0e81dfca0bb7411a..4f0463028c2edba813f30707acfa8c75b90aa19a 100644
--- a/dist/app/components/error-500.vue
+++ b/dist/app/components/error-500.vue
@@ -26,7 +26,7 @@ useHead({
   title: `${props.statusCode} - ${props.statusMessage} | ${props.appName}`,
   script: [
     {
-      innerHTML: `!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)}).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();`
+      innerHTML: `!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver((e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)})).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();`
     }
   ],
   style: [
diff --git a/dist/app/components/error-dev.vue b/dist/app/components/error-dev.vue
index 77833df60927cdf86f5abb19db1afd879e7e2454..8e0243ec92e2285ede7516f28fd464e0bfff723e 100644
--- a/dist/app/components/error-dev.vue
+++ b/dist/app/components/error-dev.vue
@@ -26,7 +26,7 @@ useHead({
   title: `${props.statusCode} - ${props.statusMessage || "Internal Server Error"}`,
   script: [
     {
-      innerHTML: `!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)}).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();`
+      innerHTML: `!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver((e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)})).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();`
     }
   ],
   style: [
diff --git a/dist/app/components/island-renderer.d.ts b/dist/app/components/island-renderer.d.ts
deleted file mode 100644
index 33ebee4e499af20ebae33ab7489f144ca7f9253a..0000000000000000000000000000000000000000
diff --git a/dist/app/components/island-renderer.js b/dist/app/components/island-renderer.js
deleted file mode 100644
index 29d6a08a9f611f63a14a420ff1445b70a45379d4..0000000000000000000000000000000000000000
diff --git a/dist/app/components/nuxt-island.d.ts b/dist/app/components/nuxt-island.d.ts
index 7fb9a5fe489c1a03f8bfeccb6574628302905c1b..40ffe00c2af77b60f831ee89591e57b2e038962a 100644
--- a/dist/app/components/nuxt-island.d.ts
+++ b/dist/app/components/nuxt-island.d.ts
@@ -1,4 +1,4 @@
-import type { PropType, RendererNode, VNode } from 'vue';
+import type { PropType } from 'vue';
 declare const _default: import("vue").DefineComponent<import("vue").ExtractPropTypes<{
     name: {
         type: StringConstructor;
@@ -25,13 +25,7 @@ declare const _default: import("vue").DefineComponent<import("vue").ExtractPropT
         type: BooleanConstructor;
         default: boolean;
     };
-}>, (_ctx: any, _cache: any) => (VNode<RendererNode, import("vue").RendererElement, {
-    [key: string]: any;
-}> | VNode<RendererNode, import("vue").RendererElement, {
-    [key: string]: any;
-}>[])[] | VNode<any, any, {
-    [key: string]: any;
-}>[], {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, "error"[], "error", import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<{
+}>, () => any, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, "error"[], "error", import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<{
     name: {
         type: StringConstructor;
         required: true;
diff --git a/dist/app/components/nuxt-island.js b/dist/app/components/nuxt-island.js
index 71ace1b1242a03419444f5fee57f676a3d7332a7..bebd86618c04a8beede94b79649e1da359033272 100644
--- a/dist/app/components/nuxt-island.js
+++ b/dist/app/components/nuxt-island.js
@@ -1,42 +1,31 @@
-import { Fragment, Teleport, computed, createStaticVNode, createVNode, defineComponent, getCurrentInstance, h, nextTick, onBeforeUnmount, onMounted, ref, shallowRef, toRaw, watch, withMemo } from "vue";
+import { computed, defineComponent, getCurrentInstance, onBeforeUnmount, onMounted, ref, shallowRef, useId, watch } from "vue";
 import { debounce } from "perfect-debounce";
 import { hash } from "ohash";
 import { appendResponseHeader } from "h3";
 import { randomUUID } from "uncrypto";
 import { joinURL, withQuery } from "ufo";
+import { renderOnigiri } from "vue-onigiri/runtime/deserialize";
+import { join } from "pathe";
 import { useNuxtApp, useRuntimeConfig } from "../nuxt.js";
 import { prerenderRoutes, useRequestEvent } from "../composables/ssr.js";
 import { injectHead } from "../composables/head.js";
-import { getFragmentHTML, isEndFragment, isStartFragment } from "./utils.js";
-import { appBaseURL, remoteComponentIslands, selectiveClient } from "#build/nuxt.config.mjs";
+import { remoteComponentIslands } from "#build/nuxt.config.mjs";
+const viteFetch = import.meta.server 
+  ? import.meta.dev 
+    ? (src, exportName) => import("#build/dist/server/server.mjs").then((r) => r.executeFile(src)).then((r) => {
+      return r[exportName];
+    }) 
+    : (
+      // todo path association between server and client chunks
+      ((src, exportName) => import("virtual:vue-onigiri").then((r) => {
+        console.log(src, exportName);
+        return r.default.get(src + "__" + exportName);
+      }))
+    ) 
+  : (src) => import("virtual:vue-onigiri").then(mod => (mod.default ?? mod)[`${src}#${exportName}`]);
 const pKey = "_islandPromises";
-const SSR_UID_RE = /data-island-uid="([^"]*)"/;
-const DATA_ISLAND_UID_RE = /data-island-uid(="")?(?!="[^"])/g;
-const SLOTNAME_RE = /data-island-slot="([^"]*)"/g;
-const SLOT_FALLBACK_RE = / data-island-slot="([^"]*)"[^>]*>/g;
-const ISLAND_SCOPE_ID_RE = /^<[^> ]*/;
 let id = 1;
 const getId = import.meta.client ? () => (id++).toString() : randomUUID;
-const components = import.meta.client ? /* @__PURE__ */ new Map() : void 0;
-async function loadComponents(source = appBaseURL, paths) {
-  if (!paths) {
-    return;
-  }
-  const promises = [];
-  for (const [component, item] of Object.entries(paths)) {
-    if (!components.has(component)) {
-      promises.push((async () => {
-        const chunkSource = joinURL(source, item.chunk);
-        const c = await import(
-          /* @vite-ignore */
-          chunkSource
-        ).then((m) => m.default || m);
-        components.set(component, c);
-      })());
-    }
-  }
-  await Promise.all(promises);
-}
 export default defineComponent({
   name: "NuxtIsland",
   inheritAttrs: false,
@@ -68,18 +57,16 @@ export default defineComponent({
     }
   },
   emits: ["error"],
-  async setup(props, { slots, expose, emit }) {
-    let canTeleport = import.meta.server;
-    const teleportKey = shallowRef(0);
-    const key = shallowRef(0);
-    const canLoadClientComponent = computed(() => selectiveClient && (props.dangerouslyLoadClientComponents || !props.source));
+  async setup(props, { expose, emit }) {
+    const teleportKey = ref(0);
     const error = ref(null);
     const config = useRuntimeConfig();
     const nuxtApp = useNuxtApp();
-    const filteredProps = computed(() => props.props ? Object.fromEntries(Object.entries(props.props).filter(([key2]) => !key2.startsWith("data-v-"))) : {});
+    const filteredProps = computed(() => props.props ? Object.fromEntries(Object.entries(props.props).filter(([key]) => !key.startsWith("data-v-"))) : {});
     const hashId = computed(() => hash([props.name, filteredProps.value, props.context, props.source]).replace(/[-_]/g, ""));
     const instance = getCurrentInstance();
     const event = useRequestEvent();
+    const ast = ref(nuxtApp.payload.data[`${props.name}_${hashId.value}`]?.ast);
     let activeHead;
     const eventFetch = import.meta.server ? event.fetch : import.meta.dev ? $fetch.raw : globalThis.fetch;
     const mounted = shallowRef(false);
@@ -92,100 +79,31 @@ export default defineComponent({
         activeHead.dispose();
       }
     });
-    function setPayload(key2, result) {
+    function setPayload(key, result) {
       const toRevive = {};
-      if (result.props) {
-        toRevive.props = result.props;
-      }
-      if (result.slots) {
-        toRevive.slots = result.slots;
-      }
-      if (result.components) {
-        toRevive.components = result.components;
-      }
       if (result.head) {
         toRevive.head = result.head;
       }
-      nuxtApp.payload.data[key2] = {
+      if (result.ast) {
+        toRevive.ast = result.ast;
+      }
+      nuxtApp.payload.data[key] = {
         __nuxt_island: {
-          key: key2,
+          key,
           ...import.meta.server && import.meta.prerender ? {} : { params: { ...props.context, props: props.props ? JSON.stringify(props.props) : void 0 } },
           result: toRevive
         },
         ...result
       };
     }
-    const payloads = {};
-    if (instance.vnode.el) {
-      const slots2 = toRaw(nuxtApp.payload.data[`${props.name}_${hashId.value}`])?.slots;
-      if (slots2) {
-        payloads.slots = slots2;
-      }
-      if (selectiveClient) {
-        const components2 = toRaw(nuxtApp.payload.data[`${props.name}_${hashId.value}`])?.components;
-        if (components2) {
-          payloads.components = components2;
-        }
-      }
-    }
-    const ssrHTML = ref("");
-    if (import.meta.client && instance.vnode?.el) {
-      if (import.meta.dev) {
-        let currentEl = instance.vnode.el;
-        let startEl = null;
-        let isFirstElement = true;
-        while (currentEl) {
-          if (isEndFragment(currentEl)) {
-            if (startEl !== currentEl.previousSibling) {
-              console.warn(`[\`Server components(and islands)\`] "${props.name}" must have a single root element. (HTML comments are considered elements as well.)`);
-            }
-            break;
-          } else if (!isStartFragment(currentEl) && isFirstElement) {
-            isFirstElement = false;
-            if (currentEl.nodeType === 1) {
-              startEl = currentEl;
-            }
-          }
-          currentEl = currentEl.nextSibling;
-        }
-      }
-      ssrHTML.value = getFragmentHTML(instance.vnode.el, true)?.join("") || "";
-      const key2 = `${props.name}_${hashId.value}`;
-      nuxtApp.payload.data[key2] ||= {};
-      nuxtApp.payload.data[key2].html = ssrHTML.value.replaceAll(new RegExp(`data-island-uid="${ssrHTML.value.match(SSR_UID_RE)?.[1] || ""}"`, "g"), `data-island-uid=""`);
-    }
-    const uid = ref(ssrHTML.value.match(SSR_UID_RE)?.[1] || getId());
-    const currentSlots = new Set(Object.keys(slots));
-    const availableSlots = computed(() => new Set([...ssrHTML.value.matchAll(SLOTNAME_RE)].map((m) => m[1])));
-    const html = computed(() => {
-      let html2 = ssrHTML.value;
-      if (props.scopeId) {
-        html2 = html2.replace(ISLAND_SCOPE_ID_RE, (full) => full + " " + props.scopeId);
-      }
-      if (import.meta.client && !canLoadClientComponent.value) {
-        for (const [key2, value] of Object.entries(payloads.components || {})) {
-          html2 = html2.replace(new RegExp(` data-island-uid="${uid.value}" data-island-component="${key2}"[^>]*>`), (full) => {
-            return full + value.html;
-          });
-        }
-      }
-      if (payloads.slots) {
-        return html2.replaceAll(SLOT_FALLBACK_RE, (full, slotName) => {
-          if (!currentSlots.has(slotName)) {
-            return full + (payloads.slots?.[slotName]?.fallback || "");
-          }
-          return full;
-        });
-      }
-      return html2;
-    });
+    const uid = ref(useId() || getId());
     const head = injectHead();
     async function _fetchComponent(force = false) {
-      const key2 = `${props.name}_${hashId.value}`;
-      if (!force && nuxtApp.payload.data[key2]?.html) {
-        return nuxtApp.payload.data[key2];
+      const key = `${props.name}_${hashId.value}`;
+      if (!force && nuxtApp.payload.data[key]?.html) {
+        return nuxtApp.payload.data[key];
       }
-      const url = remoteComponentIslands && props.source ? joinURL(props.source, `/__nuxt_island/${key2}.json`) : `/__nuxt_island/${key2}.json`;
+      const url = remoteComponentIslands && props.source ? joinURL(props.source, `/__nuxt_island/${key}.json`) : `/__nuxt_island/${key}.json`;
       if (import.meta.server && import.meta.prerender) {
         nuxtApp.runWithContext(() => prerenderRoutes(url));
       }
@@ -201,7 +119,7 @@ export default defineComponent({
             appendResponseHeader(event, "x-nitro-prerender", hints);
           }
         }
-        setPayload(key2, result);
+        setPayload(key, result);
         return result;
       } catch (e) {
         if (r.status !== 200) {
@@ -217,16 +135,10 @@ export default defineComponent({
       });
       try {
         const res = await nuxtApp[pKey][uid.value];
-        ssrHTML.value = res.html.replaceAll(DATA_ISLAND_UID_RE, `data-island-uid="${uid.value}"`);
-        key.value++;
-        error.value = null;
-        payloads.slots = res.slots || {};
-        payloads.components = res.components || {};
-        if (selectiveClient && import.meta.client) {
-          if (canLoadClientComponent.value && res.components) {
-            await loadComponents(props.source, res.components);
-          }
+        if (res.ast) {
+          ast.value = res.ast;
         }
+        error.value = null;
         if (res?.head) {
           if (activeHead) {
             activeHead.patch(res.head);
@@ -234,12 +146,6 @@ export default defineComponent({
             activeHead = head.push(res.head);
           }
         }
-        if (import.meta.client) {
-          nextTick(() => {
-            canTeleport = true;
-            teleportKey.value++;
-          });
-        }
       } catch (e) {
         error.value = e;
         emit("error", e);
@@ -260,68 +166,12 @@ export default defineComponent({
       fetchComponent();
     } else if (import.meta.server || !instance.vnode.el || !nuxtApp.payload.serverRendered) {
       await fetchComponent();
-    } else if (selectiveClient && canLoadClientComponent.value) {
-      await loadComponents(props.source, payloads.components);
     }
-    return (_ctx, _cache) => {
-      if (!html.value || error.value) {
-        return [slots.fallback?.({ error: error.value }) ?? createVNode("div")];
-      }
-      return [
-        withMemo([key.value], () => {
-          return createVNode(Fragment, { key: key.value }, [h(createStaticVNode(html.value || "<div></div>", 1))]);
-        }, _cache, 0),
-        // should away be triggered ONE tick after re-rendering the static node
-        withMemo([teleportKey.value], () => {
-          const teleports = [];
-          const isKeyOdd = teleportKey.value === 0 || !!(teleportKey.value && !(teleportKey.value % 2));
-          if (uid.value && html.value && (import.meta.server || props.lazy ? canTeleport : mounted.value || instance.vnode?.el)) {
-            for (const slot in slots) {
-              if (availableSlots.value.has(slot)) {
-                teleports.push(
-                  createVNode(
-                    Teleport,
-                    // use different selectors for even and odd teleportKey to force trigger the teleport
-                    { to: import.meta.client ? `${isKeyOdd ? "div" : ""}[data-island-uid="${uid.value}"][data-island-slot="${slot}"]` : `uid=${uid.value};slot=${slot}` },
-                    { default: () => (payloads.slots?.[slot]?.props?.length ? payloads.slots[slot].props : [{}]).map((data) => slots[slot]?.(data)) }
-                  )
-                );
-              }
-            }
-            if (selectiveClient) {
-              if (import.meta.server) {
-                if (payloads.components) {
-                  for (const [id2, info] of Object.entries(payloads.components)) {
-                    const { html: html2, slots: slots2 } = info;
-                    let replaced = html2.replaceAll("data-island-uid", `data-island-uid="${uid.value}"`);
-                    for (const slot in slots2) {
-                      replaced = replaced.replaceAll(`data-island-slot="${slot}">`, (full) => full + slots2[slot]);
-                    }
-                    teleports.push(createVNode(Teleport, { to: `uid=${uid.value};client=${id2}` }, {
-                      default: () => [createStaticVNode(replaced, 1)]
-                    }));
-                  }
-                }
-              } else if (canLoadClientComponent.value && payloads.components) {
-                for (const [id2, info] of Object.entries(payloads.components)) {
-                  const { props: props2, slots: slots2 } = info;
-                  const component = components.get(id2);
-                  const vnode = createVNode(Teleport, { to: `${isKeyOdd ? "div" : ""}[data-island-uid='${uid.value}'][data-island-component="${id2}"]` }, {
-                    default: () => {
-                      return [h(component, props2, Object.fromEntries(Object.entries(slots2 || {}).map(([k, v]) => [
-                        k,
-                        () => createStaticVNode(`<div style="display: contents" data-island-uid data-island-slot="${k}">${v}</div>`, 1)
-                      ])))];
-                    }
-                  });
-                  teleports.push(vnode);
-                }
-              }
-            }
-          }
-          return h(Fragment, teleports);
-        }, _cache, 1)
-      ];
+    return () => {
+      return renderOnigiri(
+        ast.value,
+        viteFetch
+      );
     };
   }
 });
diff --git a/dist/app/components/nuxt-root.vue b/dist/app/components/nuxt-root.vue
index 3d28794b56afa4fef5321a12cf1c8702928ccf0c..a5894dc18d2906055a7b12e06a7d85ca85876b2d 100644
--- a/dist/app/components/nuxt-root.vue
+++ b/dist/app/components/nuxt-root.vue
@@ -4,11 +4,7 @@
     <ErrorComponent
       v-else-if="error"
       :error="error"
-    />
-    <IslandRenderer
-      v-else-if="islandContext"
-      :context="islandContext"
-    />
+    /> 
     <component
       :is="SingleRenderer"
       v-else-if="SingleRenderer"
@@ -25,8 +21,6 @@ import { useRoute, useRouter } from "../composables/router";
 import { PageRouteSymbol } from "../components/injections";
 import AppComponent from "#build/app-component.mjs";
 import ErrorComponent from "#build/error-component.mjs";
-import { componentIslands } from "#build/nuxt.config.mjs";
-const IslandRenderer = import.meta.server && componentIslands ? defineAsyncComponent(() => import("./island-renderer").then((r) => r.default || r)) : () => null;
 const nuxtApp = useNuxtApp();
 const onResolve = nuxtApp.deferHydration();
 if (import.meta.client && nuxtApp.isHydrating) {
@@ -56,5 +50,4 @@ onErrorCaptured((err, target, info) => {
     return false;
   }
 });
-const islandContext = import.meta.server && nuxtApp.ssrContext.islandContext;
 </script>
diff --git a/dist/app/components/utils.d.ts b/dist/app/components/utils.d.ts
index e44c8cb70ff2d33f6708dd95c69b0f72f04878cd..1ad5b2d50159dad5c007df0258063c695ff4388d 100644
--- a/dist/app/components/utils.d.ts
+++ b/dist/app/components/utils.d.ts
@@ -1,4 +1,4 @@
-import type { RendererNode, VNode } from 'vue';
+import type { RendererNode } from 'vue';
 import type { RouteLocationNormalized } from 'vue-router';
 /**
  * Internal utility
@@ -37,12 +37,3 @@ export declare function vforToArray(source: any): any[];
  * @returns {string[]|undefined} An array of string which represent the content of each element. Use `.join('')` to retrieve a component vnode.el HTML
  */
 export declare function getFragmentHTML(element: RendererNode | null, withoutSlots?: boolean): string[] | undefined;
-/**
- * Return a static vnode from an element
- * Default to a div if the element is not found and if a fallback is not provided
- * @param el renderer node retrieved from the component internal instance
- * @param staticNodeFallback fallback string to use if the element is not found. Must be a valid HTML string
- */
-export declare function elToStaticVNode(el: RendererNode | null, staticNodeFallback?: string): VNode;
-export declare function isStartFragment(element: RendererNode): boolean;
-export declare function isEndFragment(element: RendererNode): boolean;
diff --git a/dist/app/components/utils.js b/dist/app/components/utils.js
index a1404a6721fb288b4a85697eb0133f39c7ff18ec..904ed639017596b5e3315d9bc90d7d3218fa5083 100644
--- a/dist/app/components/utils.js
+++ b/dist/app/components/utils.js
@@ -1,4 +1,4 @@
-import { Transition, createStaticVNode, h } from "vue";
+import { Transition, h } from "vue";
 import { isString, isPromise, isArray, isObject } from "@vue/shared";
 import { START_LOCATION } from "#build/pages";
 export const _wrapInTransition = (props, children) => {
@@ -111,16 +111,3 @@ function getFragmentChildren(element, blocks = [], withoutSlots = false) {
   }
   return blocks;
 }
-export function elToStaticVNode(el, staticNodeFallback) {
-  const fragment = el ? getFragmentHTML(el) : staticNodeFallback ? [staticNodeFallback] : void 0;
-  if (fragment) {
-    return createStaticVNode(fragment.join(""), fragment.length);
-  }
-  return h("div");
-}
-export function isStartFragment(element) {
-  return element.nodeName === "#comment" && element.nodeValue === "[";
-}
-export function isEndFragment(element) {
-  return element.nodeName === "#comment" && element.nodeValue === "]";
-}
diff --git a/dist/app/components/welcome.vue b/dist/app/components/welcome.vue
index f96b90bef3a874ad226308160b4343bc83184812..d5f863f620ef7a31a4dc629531d2db5bffcdf87b 100644
--- a/dist/app/components/welcome.vue
+++ b/dist/app/components/welcome.vue
@@ -14,7 +14,7 @@ useHead({
   title: `${props.title}`,
   script: [
     {
-      innerHTML: `!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)}).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();`
+      innerHTML: `!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver((e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)})).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();`
     }
   ],
   style: [
diff --git a/dist/app/composables/cookie.js b/dist/app/composables/cookie.js
index f6e68574ec71b468458aab2c7b5f345b48f4366b..d94d8bc5f487f29f1427b80904db9085b15dda1b 100644
--- a/dist/app/composables/cookie.js
+++ b/dist/app/composables/cookie.js
@@ -13,7 +13,7 @@ const CookieDefaults = {
   decode: (val) => destr(decodeURIComponent(val)),
   encode: (val) => encodeURIComponent(typeof val === "string" ? val : JSON.stringify(val))
 };
-const store = import.meta.client && cookieStore ? window.cookieStore : void 0;
+const store = import.meta.client && cookieStore ? globalThis.cookieStore : void 0;
 export function useCookie(name, _opts) {
   const opts = { ...CookieDefaults, ..._opts };
   opts.filter ??= (key) => key === name;
diff --git a/dist/app/composables/url.js b/dist/app/composables/url.js
index d0365905a038de1e9c97560b8863d9e3a998b80a..5c52f2de96aad974caf4ee0076cde87ce6e127e7 100644
--- a/dist/app/composables/url.js
+++ b/dist/app/composables/url.js
@@ -4,5 +4,5 @@ export function useRequestURL(opts) {
   if (import.meta.server) {
     return getRequestURL(useRequestEvent(), opts);
   }
-  return new URL(window.location.href);
+  return new URL(globalThis.location.href);
 }
diff --git a/dist/app/deserialize.d.ts b/dist/app/deserialize.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2f07a2fdeb3e30b09fb39572fda159387059cdad
--- /dev/null
+++ b/dist/app/deserialize.d.ts
@@ -0,0 +1,4 @@
+import { type VNode } from "vue";
+import { type VServerComponent } from "./shared.js";
+export declare function renderServerComponent(input?: VServerComponent): VNode | undefined;
+export declare function renderChildren(data: VServerComponent | VServerComponent[] | undefined): VNode | undefined;
diff --git a/dist/app/deserialize.js b/dist/app/deserialize.js
new file mode 100644
index 0000000000000000000000000000000000000000..4cdf208b89739d33cf180de20c10f9a916fd630e
--- /dev/null
+++ b/dist/app/deserialize.js
@@ -0,0 +1,30 @@
+import { createTextVNode, h, Fragment, Suspense } from "vue";
+import { VServerComponentType } from "./shared";
+import loader from "./components/loader";
+export function renderServerComponent(input) {
+  if (!input) return;
+  if (input.type === VServerComponentType.Text) {
+    return createTextVNode(input.text);
+  }
+  if (input.type === VServerComponentType.Element) {
+    return h(input.tag, input.props, Array.isArray(input.children) ? input.children.map(renderServerComponent) : renderServerComponent(input.children));
+  }
+  if (input.type === VServerComponentType.Component) {
+    return h(Suspense, {}, {
+      default: () => h(loader, {
+        data: input
+      })
+    });
+  }
+  if (input.type === VServerComponentType.Fragment) {
+    return Array.isArray(input.children) ? h(Fragment, input.children.map(renderServerComponent)) : renderServerComponent(input.children);
+  }
+}
+export function renderChildren(data) {
+  if (!data) return;
+  if (Array.isArray(data)) {
+    return h(Fragment, data.map(renderServerComponent));
+  } else {
+    return renderServerComponent(data);
+  }
+}
diff --git a/dist/app/entry.js b/dist/app/entry.js
index e6821aaa297411937119f71de6d86c3c2b8b2343..d5b1262991913736771a8768360b5c911e754c49 100644
--- a/dist/app/entry.js
+++ b/dist/app/entry.js
@@ -7,10 +7,11 @@ import "#build/css";
 import plugins from "#build/plugins";
 import RootComponent from "#build/root-component.mjs";
 import { appId, appSpaLoaderAttrs, multiApp, spaLoadingTemplateOutside, vueAppRootContainer } from "#build/nuxt.config.mjs";
+
 let entry;
 if (import.meta.server) {
   entry = async function createNuxtAppServer(ssrContext) {
-    const vueApp = createApp(RootComponent);
+    const vueApp = createApp(ssrContext?.rootComponent ?? RootComponent, ssrContext?.islandContext?.props);
     const nuxt = createNuxtApp({ vueApp, ssrContext });
     try {
       await applyPlugins(nuxt, plugins);
diff --git a/dist/app/island.d.ts b/dist/app/island.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..df62284ee8906db0ac4abab8abbd0064753a0ae0
--- /dev/null
+++ b/dist/app/island.d.ts
@@ -0,0 +1,7 @@
+import type { SSRContext } from "vue/server-renderer";
+import type { App, DefineComponent, VNode } from "vue";
+export declare function renderIsland(_component: DefineComponent, props: any, context?: SSRContext): Promise<any>;
+export declare function renderAsServerComponent(input: App | VNode, context?: SSRContext, props?: any): Promise<{
+    html: string;
+    ast: any;
+}>;
diff --git a/dist/app/island.js b/dist/app/island.js
new file mode 100644
index 0000000000000000000000000000000000000000..83f3a64b2f8c15845c4c2f9a4a9f40814d62d56f
--- /dev/null
+++ b/dist/app/island.js
@@ -0,0 +1,24 @@
+import { isVNode, createApp } from "vue";
+import { renderToString } from "vue/server-renderer";
+import { renderToAST } from "./serialize";
+import { h } from "vue";
+export async function renderIsland(_component, props, context = {}) {
+  const component = _component.__vnodeVersion ? await import(_component.__vnodeVersion).then((m) => m.default || m) : _component;
+  const app = createApp(() => h(component, props));
+  return await renderToAST(app, context);
+}
+export async function renderAsServerComponent(input, context = {}, props) {
+  if (isVNode(input)) {
+    return renderAsServerComponent(createApp({ render: () => input }), context);
+  }
+  if (!input.version) {
+    return renderAsServerComponent(createApp(input, props), context);
+  }
+  const htmlPromise = renderToString(input, context);
+  const astPromise = renderToAST(input, context);
+  const [html, ast] = await Promise.all([htmlPromise, astPromise]);
+  return {
+    html,
+    ast
+  };
+}
diff --git a/dist/app/nuxt.d.ts b/dist/app/nuxt.d.ts
index 084269f5159dc23cdb0b69bdedcf7f1747abdf0d..b89d2c7ae40580987459bb556276fd2798bee337 100644
--- a/dist/app/nuxt.d.ts
+++ b/dist/app/nuxt.d.ts
@@ -73,6 +73,7 @@ export interface NuxtSSRContext extends SSRContext {
     };
     /** @internal */
     _preloadManifest?: boolean;
+    rootComponent?: VNode;
 }
 export interface NuxtPayload {
     path?: string;
diff --git a/dist/core/runtime/nitro/handlers/island.d.ts b/dist/core/runtime/nitro/handlers/island.d.ts
index ea7b2201536514931228ea584d1707a694853fb9..f85583688484b69c5c0051c7cb0563db853520c6 100644
--- a/dist/core/runtime/nitro/handlers/island.d.ts
+++ b/dist/core/runtime/nitro/handlers/island.d.ts
@@ -1,4 +1,4 @@
 import type { RenderResponse } from 'nitropack/types';
 import type { NuxtIslandResponse } from '../utils/renderer/islands.js';
-declare const _default: import("h3").EventHandler<import("h3").EventHandlerRequest, Promise<NuxtIslandResponse | Partial<RenderResponse>>>;
+declare const _default: import("h3").EventHandler<import("h3").EventHandlerRequest, Promise<Partial<RenderResponse> | NuxtIslandResponse>>;
 export default _default;
diff --git a/dist/core/runtime/nitro/handlers/island.js b/dist/core/runtime/nitro/handlers/island.js
index 5d35c092874880bf098414df7f9d3410e12d7516..adc4af21cdc3778c67d872b9e631d4d64c5a763d 100644
--- a/dist/core/runtime/nitro/handlers/island.js
+++ b/dist/core/runtime/nitro/handlers/island.js
@@ -4,11 +4,11 @@ import { defineEventHandler, getQuery, readBody, setResponseHeaders } from "h3";
 import { resolveUnrefHeadInput } from "@unhead/vue";
 import { getRequestDependencies } from "vue-bundle-renderer/runtime";
 import { getQuery as getURLQuery } from "ufo";
+import { serializeApp } from "vue-onigiri/runtime/serialize";
 import { islandCache, islandPropCache } from "../utils/cache.js";
 import { createSSRContext } from "../utils/renderer/app.js";
-import { getSSRRenderer } from "../utils/renderer/build-files.js";
+import { getComponentsIslands, getSSRRenderer, getServerEntry } from "../utils/renderer/build-files.js";
 import { renderInlineStyles } from "../utils/renderer/inline-styles.js";
-import { getClientIslandResponse, getServerComponentHTML, getSlotIslandResponse } from "../utils/renderer/islands.js";
 const ISLAND_SUFFIX_RE = /\.json(?:\?.*)?$/;
 export default defineEventHandler(async (event) => {
   const nitroApp = useNitroApp();
@@ -20,6 +20,8 @@ export default defineEventHandler(async (event) => {
     return islandCache.getItem(event.path);
   }
   const islandContext = await getIslandContext(event);
+  
+const components = (await getComponentsIslands());
   const ssrContext = {
     ...createSSRContext(event),
     islandContext,
@@ -27,12 +29,13 @@ export default defineEventHandler(async (event) => {
     url: islandContext.url
   };
   const renderer = await getSSRRenderer();
-  const renderResult = await renderer.renderToString(ssrContext).catch(async (error) => {
-    await ssrContext.nuxt?.hooks.callHook("app:error", error);
-    throw error;
-  });
+  const createSSRApp = await getServerEntry();
+  console.log(components)
+  ssrContext.rootComponent = components[islandContext.name];
+  const app = await createSSRApp(ssrContext, renderer.rendererContext);
+  const ast = await app.runWithContext(() => serializeApp(app, ssrContext));
   const inlinedStyles = await renderInlineStyles(ssrContext.modules ?? []);
-  await ssrContext.nuxt?.hooks.callHook("app:rendered", { ssrContext, renderResult });
+  await ssrContext.nuxt?.hooks.callHook("app:rendered", { ssrContext });
   if (inlinedStyles.length) {
     ssrContext.head.push({ style: inlinedStyles });
   }
@@ -44,7 +47,7 @@ export default defineEventHandler(async (event) => {
         continue;
       }
       if (resource.file.includes("scoped") && !resource.file.includes("pages/")) {
-        link.push({ rel: "stylesheet", href: renderer.rendererContext.buildAssetsURL(resource.file), crossorigin: "" });
+        link.push({ rel: "stylesheet", href: renderer.rendererContext.buildAssetsURL(resource.file.replace("virtual:vsc:", "")), crossorigin: "" });
       }
     }
     if (link.length) {
@@ -64,9 +67,7 @@ export default defineEventHandler(async (event) => {
   const islandResponse = {
     id: islandContext.id,
     head: islandHead,
-    html: getServerComponentHTML(renderResult.html),
-    components: getClientIslandResponse(ssrContext),
-    slots: getSlotIslandResponse(ssrContext)
+    ast
   };
   await nitroApp.hooks.callHook("render:island", islandResponse, { event, islandContext });
   if (import.meta.prerender) {
diff --git a/dist/core/runtime/nitro/handlers/renderer.js b/dist/core/runtime/nitro/handlers/renderer.js
index 7046c97992c550e1af5e28acc258aad332ba8ebe..b27478685ca359f843db98608d61ac2a12dea274 100644
--- a/dist/core/runtime/nitro/handlers/renderer.js
+++ b/dist/core/runtime/nitro/handlers/renderer.js
@@ -15,9 +15,8 @@ import { payloadCache } from "../utils/cache.js";
 import { renderPayloadJsonScript, renderPayloadResponse, renderPayloadScript, splitPayload } from "../utils/renderer/payload.js";
 import { createSSRContext, setSSRError } from "../utils/renderer/app.js";
 import { renderInlineStyles } from "../utils/renderer/inline-styles.js";
-import { replaceIslandTeleports } from "../utils/renderer/islands.js";
 import { renderSSRHeadOptions } from "#internal/unhead.config.mjs";
-import { appHead, appTeleportAttrs, appTeleportTag, componentIslands, appManifest as isAppManifestEnabled } from "#internal/nuxt.config.mjs";
+import { appHead, appTeleportAttrs, appTeleportTag, appManifest as isAppManifestEnabled } from "#internal/nuxt.config.mjs";
 import { entryFileName } from "#internal/entry-chunk.mjs";
 import { buildAssetsURL, publicAssetsURL } from "#internal/nuxt/paths";
 globalThis.__buildAssetsURL = buildAssetsURL;
@@ -136,7 +135,7 @@ export default defineRenderHandler(async (event) => {
     ssrContext.head.push({ style: inlinedStyles });
   }
   const link = [];
-  for (const resource of Object.values(styles)) {
+  for (const resource of Object.values(styles).filter((r) => !r.file.includes("virtual:vsc:"))) {
     if (import.meta.dev && "inline" in getURLQuery(resource.file)) {
       continue;
     }
@@ -147,10 +146,10 @@ export default defineRenderHandler(async (event) => {
   }
   if (!NO_SCRIPTS) {
     ssrContext.head.push({
-      link: getPreloadLinks(ssrContext, renderer.rendererContext)
+      link: getPreloadLinks(ssrContext, renderer.rendererContext).filter((l) => !l.href.includes("virtual:vsc:"))
     }, headEntryOptions);
     ssrContext.head.push({
-      link: getPrefetchLinks(ssrContext, renderer.rendererContext)
+      link: getPrefetchLinks(ssrContext, renderer.rendererContext).filter((l) => !l.href.includes("virtual:vsc:"))
     }, headEntryOptions);
     ssrContext.head.push({
       script: _PAYLOAD_EXTRACTION ? process.env.NUXT_JSON_PAYLOADS ? renderPayloadJsonScript({ ssrContext, data: splitPayload(ssrContext).initial, src: payloadURL }) : renderPayloadScript({ ssrContext, data: splitPayload(ssrContext).initial, src: payloadURL }) : process.env.NUXT_JSON_PAYLOADS ? renderPayloadJsonScript({ ssrContext, data: ssrContext.payload }) : renderPayloadScript({ ssrContext, data: ssrContext.payload })
@@ -182,7 +181,7 @@ export default defineRenderHandler(async (event) => {
     bodyAttrs: bodyAttrs ? [bodyAttrs] : [],
     bodyPrepend: normalizeChunks([bodyTagsOpen, ssrContext.teleports?.body]),
     body: [
-      componentIslands ? replaceIslandTeleports(ssrContext, _rendered.html) : _rendered.html,
+      _rendered.html,
       APP_TELEPORT_OPEN_TAG + (HAS_APP_TELEPORTS ? joinTags([ssrContext.teleports?.[`#${appTeleportAttrs.id}`]]) : "") + APP_TELEPORT_CLOSE_TAG
     ],
     bodyAppend: [bodyTags]
diff --git a/dist/core/runtime/nitro/templates/error-500.js b/dist/core/runtime/nitro/templates/error-500.js
index ae62858380d6ad65d8193c809b294b3112210266..e2db2f5cb08e3a8fc164251f8268dc9247f47dca 100644
--- a/dist/core/runtime/nitro/templates/error-500.js
+++ b/dist/core/runtime/nitro/templates/error-500.js
@@ -2,5 +2,5 @@ import { escapeHtml } from "@vue/shared";
 const _messages = { "appName": "Nuxt", "statusCode": 500, "statusMessage": "Internal server error", "description": "This page is temporarily unavailable.", "refresh": "Refresh this page" };
 export const template = (messages) => {
   messages = { ..._messages, ...messages };
-  return '<!DOCTYPE html><html lang="en"><head><title>' + escapeHtml(messages.statusCode) + " - " + escapeHtml(messages.statusMessage) + " | " + escapeHtml(messages.appName) + `</title><meta charset="utf-8"><meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0" name="viewport"><script>!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)}).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();<\/script><style>*,:after,:before{border-color:var(--un-default-border-color,#e5e7eb);border-style:solid;border-width:0;box-sizing:border-box}:after,:before{--un-content:""}html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-moz-tab-size:4;tab-size:4;-webkit-tap-highlight-color:transparent}body{line-height:inherit;margin:0}h1,h2{font-size:inherit;font-weight:inherit}h1,h2,p{margin:0}*,:after,:before{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 transparent;--un-ring-shadow:0 0 transparent;--un-shadow-inset: ;--un-shadow:0 0 transparent;--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgba(147,197,253,.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: }.grid{display:grid}.mb-2{margin-bottom:.5rem}.mb-4{margin-bottom:1rem}.max-w-520px{max-width:520px}.min-h-screen{min-height:100vh}.place-content-center{place-content:center}.overflow-hidden{overflow:hidden}.bg-white{--un-bg-opacity:1;background-color:rgb(255 255 255/var(--un-bg-opacity))}.px-2{padding-left:.5rem;padding-right:.5rem}.text-center{text-align:center}.text-\\[80px\\]{font-size:80px}.text-2xl{font-size:1.5rem;line-height:2rem}.text-\\[\\#020420\\]{--un-text-opacity:1;color:rgb(2 4 32/var(--un-text-opacity))}.text-\\[\\#64748B\\]{--un-text-opacity:1;color:rgb(100 116 139/var(--un-text-opacity))}.font-semibold{font-weight:600}.leading-none{line-height:1}.tracking-wide{letter-spacing:.025em}.font-sans{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.tabular-nums{--un-numeric-spacing:tabular-nums;font-variant-numeric:var(--un-ordinal) var(--un-slashed-zero) var(--un-numeric-figure) var(--un-numeric-spacing) var(--un-numeric-fraction)}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}@media (prefers-color-scheme:dark){.dark\\:bg-\\[\\#020420\\]{--un-bg-opacity:1;background-color:rgb(2 4 32/var(--un-bg-opacity))}.dark\\:text-white{--un-text-opacity:1;color:rgb(255 255 255/var(--un-text-opacity))}}@media (min-width:640px){.sm\\:text-\\[110px\\]{font-size:110px}.sm\\:text-3xl{font-size:1.875rem;line-height:2.25rem}}</style></head><body class="antialiased bg-white dark:bg-[#020420] dark:text-white font-sans grid min-h-screen overflow-hidden place-content-center text-[#020420] tracking-wide"><div class="max-w-520px text-center"><h1 class="font-semibold leading-none mb-4 sm:text-[110px] tabular-nums text-[80px]">` + escapeHtml(messages.statusCode) + '</h1><h2 class="font-semibold mb-2 sm:text-3xl text-2xl">' + escapeHtml(messages.statusMessage) + '</h2><p class="mb-4 px-2 text-[#64748B] text-md">' + escapeHtml(messages.description) + "</p></div></body></html>";
+  return '<!DOCTYPE html><html lang="en"><head><title>' + escapeHtml(messages.statusCode) + " - " + escapeHtml(messages.statusMessage) + " | " + escapeHtml(messages.appName) + `</title><meta charset="utf-8"><meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0" name="viewport"><script>!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver((e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)})).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();<\/script><style>*,:after,:before{border-color:var(--un-default-border-color,#e5e7eb);border-style:solid;border-width:0;box-sizing:border-box}:after,:before{--un-content:""}html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-moz-tab-size:4;tab-size:4;-webkit-tap-highlight-color:transparent}body{line-height:inherit;margin:0}h1,h2{font-size:inherit;font-weight:inherit}h1,h2,p{margin:0}*,:after,:before{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 transparent;--un-ring-shadow:0 0 transparent;--un-shadow-inset: ;--un-shadow:0 0 transparent;--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgba(147,197,253,.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: }.grid{display:grid}.mb-2{margin-bottom:.5rem}.mb-4{margin-bottom:1rem}.max-w-520px{max-width:520px}.min-h-screen{min-height:100vh}.place-content-center{place-content:center}.overflow-hidden{overflow:hidden}.bg-white{--un-bg-opacity:1;background-color:rgb(255 255 255/var(--un-bg-opacity))}.px-2{padding-left:.5rem;padding-right:.5rem}.text-center{text-align:center}.text-\\[80px\\]{font-size:80px}.text-2xl{font-size:1.5rem;line-height:2rem}.text-\\[\\#020420\\]{--un-text-opacity:1;color:rgb(2 4 32/var(--un-text-opacity))}.text-\\[\\#64748B\\]{--un-text-opacity:1;color:rgb(100 116 139/var(--un-text-opacity))}.font-semibold{font-weight:600}.leading-none{line-height:1}.tracking-wide{letter-spacing:.025em}.font-sans{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.tabular-nums{--un-numeric-spacing:tabular-nums;font-variant-numeric:var(--un-ordinal) var(--un-slashed-zero) var(--un-numeric-figure) var(--un-numeric-spacing) var(--un-numeric-fraction)}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}@media (prefers-color-scheme:dark){.dark\\:bg-\\[\\#020420\\]{--un-bg-opacity:1;background-color:rgb(2 4 32/var(--un-bg-opacity))}.dark\\:text-white{--un-text-opacity:1;color:rgb(255 255 255/var(--un-text-opacity))}}@media (min-width:640px){.sm\\:text-\\[110px\\]{font-size:110px}.sm\\:text-3xl{font-size:1.875rem;line-height:2.25rem}}</style></head><body class="antialiased bg-white dark:bg-[#020420] dark:text-white font-sans grid min-h-screen overflow-hidden place-content-center text-[#020420] tracking-wide"><div class="max-w-520px text-center"><h1 class="font-semibold leading-none mb-4 sm:text-[110px] tabular-nums text-[80px]">` + escapeHtml(messages.statusCode) + '</h1><h2 class="font-semibold mb-2 sm:text-3xl text-2xl">' + escapeHtml(messages.statusMessage) + '</h2><p class="mb-4 px-2 text-[#64748B] text-md">' + escapeHtml(messages.description) + "</p></div></body></html>";
 };
diff --git a/dist/core/runtime/nitro/templates/error-dev.js b/dist/core/runtime/nitro/templates/error-dev.js
index 20087a8abcee6700b182fd521f39a5aba63969f9..d2b0c22d188cdcb0025c0b97ec28a437e41b7f37 100644
--- a/dist/core/runtime/nitro/templates/error-dev.js
+++ b/dist/core/runtime/nitro/templates/error-dev.js
@@ -2,5 +2,5 @@ import { escapeHtml } from "@vue/shared";
 const _messages = { "appName": "Nuxt", "statusCode": 500, "statusMessage": "Server error", "description": "An error occurred in the application and the page could not be served.", "stack": "" };
 export const template = (messages) => {
   messages = { ..._messages, ...messages };
-  return '<!DOCTYPE html><html lang="en"><head><title>' + escapeHtml(messages.statusCode) + " - " + escapeHtml(messages.statusMessage || "Internal Server Error") + `</title><meta charset="utf-8"><meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0" name="viewport"><script>!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)}).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();<\/script><style>*,:after,:before{border-color:var(--un-default-border-color,#e5e7eb);border-style:solid;border-width:0;box-sizing:border-box}:after,:before{--un-content:""}html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-moz-tab-size:4;tab-size:4;-webkit-tap-highlight-color:transparent}body{line-height:inherit;margin:0}h1{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}h1,p{margin:0}*,:after,:before{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 transparent;--un-ring-shadow:0 0 transparent;--un-shadow-inset: ;--un-shadow:0 0 transparent;--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgba(147,197,253,.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: }.absolute{position:absolute}.top-6{top:1.5rem}.z-10{z-index:10}.mx-auto{margin-left:auto;margin-right:auto}.mb-4{margin-bottom:1rem}.mb-8{margin-bottom:2rem}.inline-block{display:inline-block}.h-auto{height:auto}.min-h-screen{min-height:100vh}.flex{display:flex}.flex-1{flex:1 1 0%}.flex-col{flex-direction:column}.overflow-y-auto{overflow-y:auto}.border{border-width:1px}.border-b-0{border-bottom-width:0}.border-black\\/5{border-color:#0000000d}.rounded-t-md{border-top-left-radius:.375rem;border-top-right-radius:.375rem}.bg-gray-50\\/50{background-color:#f5f5f580}.bg-white{--un-bg-opacity:1;background-color:rgb(255 255 255/var(--un-bg-opacity))}.p-8{padding:2rem}.px-10{padding-left:2.5rem;padding-right:2.5rem}.pt-12{padding-top:3rem}.text-6xl{font-size:3.75rem;line-height:1}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-black{--un-text-opacity:1;color:rgb(0 0 0/var(--un-text-opacity))}.hover\\:text-\\[\\#00DC82\\]:hover{--un-text-opacity:1;color:rgb(0 220 130/var(--un-text-opacity))}.font-light{font-weight:300}.font-medium{font-weight:500}.leading-tight{line-height:1.25}.font-sans{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.hover\\:underline:hover{text-decoration-line:underline}.underline-offset-3{text-underline-offset:3px}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}@media (prefers-color-scheme:dark){.dark\\:border-white\\/10{border-color:#ffffff1a}.dark\\:bg-\\[\\#020420\\]{--un-bg-opacity:1;background-color:rgb(2 4 32/var(--un-bg-opacity))}.dark\\:bg-white\\/5{background-color:#ffffff0d}.dark\\:text-white{--un-text-opacity:1;color:rgb(255 255 255/var(--un-text-opacity))}}@media (min-width:640px){.sm\\:right-6{right:1.5rem}.sm\\:text-2xl{font-size:1.5rem;line-height:2rem}.sm\\:text-8xl{font-size:6rem;line-height:1}}</style></head><body class="antialiased bg-white dark:bg-[#020420] dark:text-white flex flex-col font-sans min-h-screen pt-12 px-10 text-black"><h1 class="font-medium mb-4 sm:text-8xl text-6xl">` + escapeHtml(messages.statusCode) + '</h1><p class="font-light leading-tight mb-8 sm:text-2xl text-xl">' + escapeHtml(messages.description) + '</p><a href="https://nuxt.com/docs/getting-started/error-handling?utm_source=nuxt-error-dev-page" target="_blank" class="absolute font-medium hover:text-[#00DC82] hover:underline inline-block mx-auto sm:right-6 text-sm top-6 underline-offset-3">Customize this page</a><div class="bg-gray-50/50 border border-b-0 border-black/5 dark:bg-white/5 dark:border-white/10 flex-1 h-auto overflow-y-auto rounded-t-md"><div class="font-light leading-tight p-8 text-xl z-10">' + escapeHtml(messages.stack) + "</div></div></body></html>";
+  return '<!DOCTYPE html><html lang="en"><head><title>' + escapeHtml(messages.statusCode) + " - " + escapeHtml(messages.statusMessage || "Internal Server Error") + `</title><meta charset="utf-8"><meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0" name="viewport"><script>!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver((e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)})).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();<\/script><style>*,:after,:before{border-color:var(--un-default-border-color,#e5e7eb);border-style:solid;border-width:0;box-sizing:border-box}:after,:before{--un-content:""}html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-moz-tab-size:4;tab-size:4;-webkit-tap-highlight-color:transparent}body{line-height:inherit;margin:0}h1{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}h1,p{margin:0}*,:after,:before{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 transparent;--un-ring-shadow:0 0 transparent;--un-shadow-inset: ;--un-shadow:0 0 transparent;--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgba(147,197,253,.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: }.absolute{position:absolute}.top-6{top:1.5rem}.z-10{z-index:10}.mx-auto{margin-left:auto;margin-right:auto}.mb-4{margin-bottom:1rem}.mb-8{margin-bottom:2rem}.inline-block{display:inline-block}.h-auto{height:auto}.min-h-screen{min-height:100vh}.flex{display:flex}.flex-1{flex:1 1 0%}.flex-col{flex-direction:column}.overflow-y-auto{overflow-y:auto}.border{border-width:1px}.border-b-0{border-bottom-width:0}.border-black\\/5{border-color:#0000000d}.rounded-t-md{border-top-left-radius:.375rem;border-top-right-radius:.375rem}.bg-gray-50\\/50{background-color:#f5f5f580}.bg-white{--un-bg-opacity:1;background-color:rgb(255 255 255/var(--un-bg-opacity))}.p-8{padding:2rem}.px-10{padding-left:2.5rem;padding-right:2.5rem}.pt-12{padding-top:3rem}.text-6xl{font-size:3.75rem;line-height:1}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-black{--un-text-opacity:1;color:rgb(0 0 0/var(--un-text-opacity))}.hover\\:text-\\[\\#00DC82\\]:hover{--un-text-opacity:1;color:rgb(0 220 130/var(--un-text-opacity))}.font-light{font-weight:300}.font-medium{font-weight:500}.leading-tight{line-height:1.25}.font-sans{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.hover\\:underline:hover{text-decoration-line:underline}.underline-offset-3{text-underline-offset:3px}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}@media (prefers-color-scheme:dark){.dark\\:border-white\\/10{border-color:#ffffff1a}.dark\\:bg-\\[\\#020420\\]{--un-bg-opacity:1;background-color:rgb(2 4 32/var(--un-bg-opacity))}.dark\\:bg-white\\/5{background-color:#ffffff0d}.dark\\:text-white{--un-text-opacity:1;color:rgb(255 255 255/var(--un-text-opacity))}}@media (min-width:640px){.sm\\:right-6{right:1.5rem}.sm\\:text-2xl{font-size:1.5rem;line-height:2rem}.sm\\:text-8xl{font-size:6rem;line-height:1}}</style></head><body class="antialiased bg-white dark:bg-[#020420] dark:text-white flex flex-col font-sans min-h-screen pt-12 px-10 text-black"><h1 class="font-medium mb-4 sm:text-8xl text-6xl">` + escapeHtml(messages.statusCode) + '</h1><p class="font-light leading-tight mb-8 sm:text-2xl text-xl">' + escapeHtml(messages.description) + '</p><a href="https://nuxt.com/docs/getting-started/error-handling?utm_source=nuxt-error-dev-page" target="_blank" class="absolute font-medium hover:text-[#00DC82] hover:underline inline-block mx-auto sm:right-6 text-sm top-6 underline-offset-3">Customize this page</a><div class="bg-gray-50/50 border border-b-0 border-black/5 dark:bg-white/5 dark:border-white/10 flex-1 h-auto overflow-y-auto rounded-t-md"><div class="font-light leading-tight p-8 text-xl z-10">' + escapeHtml(messages.stack) + "</div></div></body></html>";
 };
diff --git a/dist/core/runtime/nitro/utils/renderer/build-files.d.ts b/dist/core/runtime/nitro/utils/renderer/build-files.d.ts
index 53ccf5705763b46fde817535789b2712b1d7853c..db27b7563f32275c4ad297bfa8e4b8271114bd1a 100644
--- a/dist/core/runtime/nitro/utils/renderer/build-files.d.ts
+++ b/dist/core/runtime/nitro/utils/renderer/build-files.d.ts
@@ -1,4 +1,6 @@
 import type { NuxtSSRContext } from 'nuxt/app';
+export declare const getServerEntry: () => Promise<any>;
+export declare const getComponentsIslands: () => Promise<any>;
 export declare const getSSRRenderer: () => Promise<{
     rendererContext: import("vue-bundle-renderer/runtime").RendererContext;
     renderToString(ssrContext: import("vue-bundle-renderer/runtime").SSRContext): Promise<{
diff --git a/dist/core/runtime/nitro/utils/renderer/build-files.js b/dist/core/runtime/nitro/utils/renderer/build-files.js
index c1f27b5c0fa710386d83f5bb44162f9176b260c2..48be82c245967a9f2ef7c9d3530f8ee6e26e6b55 100644
--- a/dist/core/runtime/nitro/utils/renderer/build-files.js
+++ b/dist/core/runtime/nitro/utils/renderer/build-files.js
@@ -8,7 +8,14 @@ import { appRootAttrs, appRootTag, appSpaLoaderAttrs, appSpaLoaderTag, spaLoadin
 import { buildAssetsURL } from "#internal/nuxt/paths";
 const APP_ROOT_OPEN_TAG = `<${appRootTag}${propsToString(appRootAttrs)}>`;
 const APP_ROOT_CLOSE_TAG = `</${appRootTag}>`;
-const getServerEntry = () => import("#build/dist/server/server.mjs").then((r) => r.default || r);
+export const getServerEntry = () => import("#build/dist/server/server.mjs").then((r) => r.default || r);
+export const getComponentsIslands = () => import("#build/dist/server/components.islands.mjs").then((r) => {
+  if(import.meta.dev) { 
+    return r.default().then(r => r.islandComponents)
+  }
+   return r.islandComponents
+});
+
 const getClientManifest = () => import("#build/dist/server/client.manifest.mjs").then((r) => r.default || r).then((r) => typeof r === "function" ? r() : r);
 export const getSSRRenderer = lazyCachedFunction(async () => {
   const manifest = await getClientManifest();
diff --git a/dist/core/runtime/nitro/utils/renderer/islands.d.ts b/dist/core/runtime/nitro/utils/renderer/islands.d.ts
index bd881c1d4120c2555cc7c07178e7dc0328647138..2dece41cd51f289983bd22a57a3817c1b19e359e 100644
--- a/dist/core/runtime/nitro/utils/renderer/islands.d.ts
+++ b/dist/core/runtime/nitro/utils/renderer/islands.d.ts
@@ -1,13 +1,4 @@
 import type { SerializableHead } from '@unhead/vue/types';
-import type { NuxtSSRContext } from '#app/nuxt';
-/**
- * remove the root node from the html body
- */
-export declare function getServerComponentHTML(body: string): string;
-export declare function getSlotIslandResponse(ssrContext: NuxtSSRContext): NuxtIslandResponse['slots'];
-export declare function getClientIslandResponse(ssrContext: NuxtSSRContext): NuxtIslandResponse['components'];
-export declare function getComponentSlotTeleport(clientUid: string, teleports: Record<string, string>): Record<string, string>;
-export declare function replaceIslandTeleports(ssrContext: NuxtSSRContext, html: string): string;
 export interface NuxtIslandSlotResponse {
     props: Array<unknown>;
     fallback?: string;
@@ -22,11 +13,8 @@ export interface NuxtIslandContext {
 }
 export interface NuxtIslandResponse {
     id?: string;
-    html: string;
     head: SerializableHead;
-    props?: Record<string, Record<string, any>>;
-    components?: Record<string, NuxtIslandClientResponse>;
-    slots?: Record<string, NuxtIslandSlotResponse>;
+    ast: any;
 }
 export interface NuxtIslandClientResponse {
     html: string;
diff --git a/dist/core/runtime/nitro/utils/renderer/islands.js b/dist/core/runtime/nitro/utils/renderer/islands.js
index 9d3a049702291c09150ca9c187a3b6a1aef5988e..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 100644
--- a/dist/core/runtime/nitro/utils/renderer/islands.js
+++ b/dist/core/runtime/nitro/utils/renderer/islands.js
@@ -1,82 +0,0 @@
-import { appRootTag } from "#internal/nuxt.config.mjs";
-const ROOT_NODE_REGEX = new RegExp(`^<${appRootTag}[^>]*>([\\s\\S]*)<\\/${appRootTag}>$`);
-export function getServerComponentHTML(body) {
-  const match = body.match(ROOT_NODE_REGEX);
-  return match?.[1] || body;
-}
-const SSR_SLOT_TELEPORT_MARKER = /^uid=([^;]*);slot=(.*)$/;
-const SSR_CLIENT_TELEPORT_MARKER = /^uid=([^;]*);client=(.*)$/;
-const SSR_CLIENT_SLOT_MARKER = /^island-slot=([^;]*);(.*)$/;
-export function getSlotIslandResponse(ssrContext) {
-  if (!ssrContext.islandContext || !Object.keys(ssrContext.islandContext.slots).length) {
-    return void 0;
-  }
-  const response = {};
-  for (const [name, slot] of Object.entries(ssrContext.islandContext.slots)) {
-    response[name] = {
-      ...slot,
-      fallback: ssrContext.teleports?.[`island-fallback=${name}`]
-    };
-  }
-  return response;
-}
-export function getClientIslandResponse(ssrContext) {
-  if (!ssrContext.islandContext || !Object.keys(ssrContext.islandContext.components).length) {
-    return void 0;
-  }
-  const response = {};
-  for (const [clientUid, component] of Object.entries(ssrContext.islandContext.components)) {
-    const html = ssrContext.teleports?.[clientUid]?.replaceAll("<!--teleport start anchor-->", "") || "";
-    response[clientUid] = {
-      ...component,
-      html,
-      slots: getComponentSlotTeleport(clientUid, ssrContext.teleports ?? {})
-    };
-  }
-  return response;
-}
-export function getComponentSlotTeleport(clientUid, teleports) {
-  const entries = Object.entries(teleports);
-  const slots = {};
-  for (const [key, value] of entries) {
-    const match = key.match(SSR_CLIENT_SLOT_MARKER);
-    if (match) {
-      const [, id, slot] = match;
-      if (!slot || clientUid !== id) {
-        continue;
-      }
-      slots[slot] = value;
-    }
-  }
-  return slots;
-}
-export function replaceIslandTeleports(ssrContext, html) {
-  const { teleports, islandContext } = ssrContext;
-  if (islandContext || !teleports) {
-    return html;
-  }
-  for (const key in teleports) {
-    const matchClientComp = key.match(SSR_CLIENT_TELEPORT_MARKER);
-    if (matchClientComp) {
-      const [, uid, clientId] = matchClientComp;
-      if (!uid || !clientId) {
-        continue;
-      }
-      html = html.replace(new RegExp(` data-island-uid="${uid}" data-island-component="${clientId}"[^>]*>`), (full) => {
-        return full + teleports[key];
-      });
-      continue;
-    }
-    const matchSlot = key.match(SSR_SLOT_TELEPORT_MARKER);
-    if (matchSlot) {
-      const [, uid, slot] = matchSlot;
-      if (!uid || !slot) {
-        continue;
-      }
-      html = html.replace(new RegExp(` data-island-uid="${uid}" data-island-slot="${slot}"[^>]*>`), (full) => {
-        return full + teleports[key];
-      });
-    }
-  }
-  return html;
-}
diff --git a/dist/index.mjs b/dist/index.mjs
index 11965d7262242d1981705e895515c6b15a93e8f5..451bd1b08897172bd6b9c93f606daaee49adf3a6 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -5,7 +5,7 @@ import { AsyncLocalStorage } from 'node:async_hooks';
 import { dirname, resolve, normalize, basename, extname, relative, isAbsolute, join } from 'pathe';
 import { createHooks, createDebugger } from 'hookable';
 import ignore from 'ignore';
-import { useLogger, tryUseNuxt, useNuxt, directoryToURL, getLayerDirectories, resolveFiles, resolvePath, defineNuxtModule, findPath, addPlugin, addTemplate, addTypeTemplate, addComponent, useNitro, addBuildPlugin, isIgnored, resolveAlias as resolveAlias$1, addPluginTemplate, addImportsSources, addVitePlugin, createIsIgnored, updateTemplates, tryResolveModule, normalizeModuleTranspilePath, resolveNuxtModule, resolveIgnorePatterns, logger as logger$1, createResolver, importModule, tryImportModule, runWithNuxtContext, nuxtCtx, loadNuxtConfig, addWebpackPlugin, addServerPlugin, installModules, addServerTemplate, addServerHandler, addRouteMiddleware, resolveModuleWithOptions, normalizeTemplate, normalizePlugin } from '@nuxt/kit';
+import { useLogger, tryUseNuxt, useNuxt, directoryToURL, getLayerDirectories, resolveFiles, resolvePath, defineNuxtModule, findPath, addPlugin, addTemplate, addTypeTemplate, addComponent, useNitro, addBuildPlugin, isIgnored, resolveAlias as resolveAlias$1, addPluginTemplate, addImportsSources, createIsIgnored, updateTemplates, tryResolveModule, normalizeModuleTranspilePath, resolveNuxtModule, resolveIgnorePatterns, logger as logger$1, createResolver, importModule, tryImportModule, runWithNuxtContext, nuxtCtx, loadNuxtConfig, addVitePlugin, addWebpackPlugin, addServerPlugin, installModules, addServerTemplate, addServerHandler, addRouteMiddleware, resolveModuleWithOptions, normalizeTemplate, normalizePlugin } from '@nuxt/kit';
 import { resolvePackageJSON, readPackageJSON } from 'pkg-types';
 import { hash, isEqual, serialize } from 'ohash';
 import consola, { consola as consola$1 } from 'consola';
@@ -39,8 +39,8 @@ import { stripLiteral } from 'strip-literal';
 import { unheadVueComposablesImports } from '@unhead/vue';
 import { defineUnimportPreset, createUnimport, toExports, scanDirExports } from 'unimport';
 import { glob } from 'tinyglobby';
-import { parse, walk as walk$1, ELEMENT_NODE } from 'ultrahtml';
 import { parseQuery as parseQuery$1 } from 'vue-router';
+import { parse, walk as walk$1 } from 'ultrahtml';
 import { createTransformer } from 'unctx/transform';
 import { cpus } from 'node:os';
 import { createNitro, scanHandlers, writeTypes, copyPublicAssets, prepare, build as build$1, prerender, createDevServer } from 'nitropack';
@@ -1816,6 +1816,7 @@ export default {
     nuxt.hooks.hook("nitro:config", (config) => {
       config.virtual["#internal/unhead-options.mjs"] = () => nuxt.vfs["#build/unhead-options.mjs"] || "";
       config.virtual["#internal/unhead.config.mjs"] = () => nuxt.vfs["#build/unhead.config.mjs"] || "";
+      config.virtual["#internal/components.islands.mjs"] = () => nuxt.vfs["#build/components.islands.mjs"] || "";
     });
     addPlugin({ src: resolve(runtimeDir, "plugins/unhead") });
   }
@@ -2157,7 +2158,7 @@ const componentsIslandsTemplate = {
       component.mode === "server" && !components.some((c) => c.pascalName === component.pascalName && c.mode === "client")
     );
     const pageExports = pages?.filter((p) => p.mode === "server" && p.file && p.name).map((p) => {
-      return `"page_${p.name}": defineAsyncComponent(${genDynamicImport(p.file)}.then(c => c.default || c))`;
+      return `"page_${p.name}": defineAsyncComponent(${genDynamicImport("virtual:vsc:" + p.file)}.then(c => c.default || c))`;
     }) || [];
     return [
       "import { defineAsyncComponent } from 'vue'",
@@ -2166,19 +2167,19 @@ const componentsIslandsTemplate = {
         (c) => {
           const exp = c.export === "default" ? "c.default || c" : `c['${c.export}']`;
           const comment = createImportMagicComments(c);
-          return `  "${c.pascalName}": defineAsyncComponent(${genDynamicImport(c.filePath, { comment })}.then(c => ${exp}))`;
+          return `  "${c.pascalName}": defineAsyncComponent(${genDynamicImport("virtual:vsc:" + c.filePath, { comment })}.then(c => ${exp}))`;
         }
       ).concat(pageExports).join(",\n"),
       "}"
     ].join("\n");
-  }
+  },
+  write: true
 };
 const NON_VUE_RE = /\b\.(?!vue)\w+$/g;
-function resolveComponentTypes(nuxt, app) {
-  const buildDir = nuxt.options.buildDir;
+function resolveComponentTypes(app, baseDir) {
   const serverPlaceholderPath = resolve(distDir, "app/components/server-placeholder");
   const componentTypes = app.components.filter((c) => !c.island).map((c) => {
-    const type = `typeof ${genDynamicImport(isAbsolute(c.filePath) ? relative(buildDir, c.filePath).replace(NON_VUE_RE, "") : c.filePath.replace(NON_VUE_RE, ""), { wrapper: false })}['${c.export}']`;
+    const type = `typeof ${genDynamicImport(isAbsolute(c.filePath) ? relative(baseDir, c.filePath).replace(NON_VUE_RE, "") : c.filePath.replace(NON_VUE_RE, ""), { wrapper: false })}['${c.export}']`;
     const isServerOnly = c.mode === "server" && c.filePath !== serverPlaceholderPath && !app.components.some((other) => other.pascalName === c.pascalName && other.mode === "client");
     return [
       c.pascalName,
@@ -2204,7 +2205,7 @@ const componentsDeclarationTemplate = {
   filename: "components.d.ts",
   write: true,
   getContents: ({ app, nuxt }) => {
-    const componentTypes = resolveComponentTypes(nuxt, app);
+    const componentTypes = resolveComponentTypes(app, nuxt.options.buildDir);
     return `
 import type { DefineComponent, SlotsType } from 'vue'
 ${nuxt.options.experimental.componentIslands ? islandType : ""}
@@ -2220,7 +2221,7 @@ export const componentNames: string[]
 const componentsTypeTemplate = {
   filename: "types/components.d.ts",
   getContents: ({ app, nuxt }) => {
-    const componentTypes = resolveComponentTypes(nuxt, app);
+    const componentTypes = resolveComponentTypes(app, join(nuxt.options.buildDir, "types"));
     return `
 import type { DefineComponent, SlotsType } from 'vue'
 ${nuxt.options.experimental.componentIslands ? islandType : ""}
@@ -2506,216 +2507,6 @@ function findComponent(components, name, mode) {
   return otherModeComponent;
 }
 
-const SCRIPT_RE$2 = /<script[^>]*>/i;
-const SCRIPT_RE_GLOBAL = /<script[^>]*>/gi;
-const HAS_SLOT_OR_CLIENT_RE = /<slot[^>]*>|nuxt-client/;
-const TEMPLATE_RE$1 = /<template>[\s\S]*<\/template>/;
-const NUXTCLIENT_ATTR_RE = /\s:?nuxt-client(?:="[^"]*")?/g;
-const IMPORT_CODE = "\nimport { mergeProps as __mergeProps } from 'vue'\nimport { vforToArray as __vforToArray } from '#app/components/utils'\nimport NuxtTeleportIslandComponent from '#app/components/nuxt-teleport-island-component'\nimport NuxtTeleportSsrSlot from '#app/components/nuxt-teleport-island-slot'";
-const EXTRACTED_ATTRS_RE = /v-(?:if|else-if|else)(?:="[^"]*")?/g;
-const KEY_RE = /:?key="[^"]"/g;
-function wrapWithVForDiv(code, vfor) {
-  return `<div v-for="${vfor}" style="display: contents;">${code}</div>`;
-}
-const IslandsTransformPlugin = (options) => createUnplugin((_options, meta) => {
-  const isVite = meta.framework === "vite";
-  return {
-    name: "nuxt:server-only-component-transform",
-    enforce: "pre",
-    transformInclude(id) {
-      if (!isVue(id)) {
-        return false;
-      }
-      if (isVite && options.selectiveClient === "deep") {
-        return true;
-      }
-      const components = options.getComponents();
-      const islands = components.filter(
-        (component) => component.island || component.mode === "server" && !components.some((c) => c.pascalName === component.pascalName && c.mode === "client")
-      );
-      const { pathname } = parseURL(decodeURIComponent(pathToFileURL(id).href));
-      return islands.some((c) => c.filePath === pathname);
-    },
-    transform: {
-      filter: {
-        code: {
-          include: [HAS_SLOT_OR_CLIENT_RE]
-        }
-      },
-      async handler(code, id) {
-        const template = code.match(TEMPLATE_RE$1);
-        if (!template) {
-          return;
-        }
-        const startingIndex = template.index || 0;
-        const s = new MagicString(code);
-        if (!SCRIPT_RE$2.test(code)) {
-          s.prepend("<script setup>" + IMPORT_CODE + "<\/script>");
-        } else {
-          s.replace(SCRIPT_RE_GLOBAL, (full) => {
-            return full + IMPORT_CODE;
-          });
-        }
-        let hasNuxtClient = false;
-        const ast = parse(template[0]);
-        await walk$1(ast, (node) => {
-          if (node.type !== ELEMENT_NODE) {
-            return;
-          }
-          if (node.name === "slot") {
-            const { attributes: attributes2, children, loc: loc2 } = node;
-            const slotName = attributes2.name ?? "default";
-            if (attributes2.name) {
-              delete attributes2.name;
-            }
-            if (attributes2["v-bind"]) {
-              attributes2._bind = extractAttributes(attributes2, ["v-bind"])["v-bind"];
-            }
-            const teleportAttributes = extractAttributes(attributes2, ["v-if", "v-else-if", "v-else"]);
-            const bindings = getPropsToString(attributes2);
-            s.appendLeft(startingIndex + loc2[0].start, `<NuxtTeleportSsrSlot${attributeToString(teleportAttributes)} name="${slotName}" :props="${bindings}">`);
-            if (children.length) {
-              const attrString = attributeToString(attributes2);
-              const slice = code.slice(startingIndex + loc2[0].end, startingIndex + loc2[1].start).replaceAll(KEY_RE, "");
-              s.overwrite(startingIndex + loc2[0].start, startingIndex + loc2[1].end, `<slot${attrString.replaceAll(EXTRACTED_ATTRS_RE, "")}/><template #fallback>${attributes2["v-for"] ? wrapWithVForDiv(slice, attributes2["v-for"]) : slice}</template>`);
-            } else {
-              s.overwrite(startingIndex + loc2[0].start, startingIndex + loc2[0].end, code.slice(startingIndex + loc2[0].start, startingIndex + loc2[0].end).replaceAll(EXTRACTED_ATTRS_RE, ""));
-            }
-            s.appendRight(startingIndex + loc2[1].end, "</NuxtTeleportSsrSlot>");
-            return;
-          }
-          if (!("nuxt-client" in node.attributes) && !(":nuxt-client" in node.attributes)) {
-            return;
-          }
-          hasNuxtClient = true;
-          if (!isVite || !options.selectiveClient) {
-            return;
-          }
-          const { loc, attributes } = node;
-          const attributeValue = attributes[":nuxt-client"] || attributes["nuxt-client"] || "true";
-          const wrapperAttributes = extractAttributes(attributes, ["v-if", "v-else-if", "v-else"]);
-          let startTag = code.slice(startingIndex + loc[0].start, startingIndex + loc[0].end).replace(NUXTCLIENT_ATTR_RE, "");
-          if (wrapperAttributes) {
-            startTag = startTag.replaceAll(EXTRACTED_ATTRS_RE, "");
-          }
-          s.appendLeft(startingIndex + loc[0].start, `<NuxtTeleportIslandComponent${attributeToString(wrapperAttributes)} :nuxt-client="${attributeValue}">`);
-          s.overwrite(startingIndex + loc[0].start, startingIndex + loc[0].end, startTag);
-          s.appendRight(startingIndex + loc[1].end, "</NuxtTeleportIslandComponent>");
-        });
-        if (hasNuxtClient) {
-          if (!options.selectiveClient) {
-            console.warn(`The \`nuxt-client\` attribute and client components within islands are only supported when \`experimental.componentIslands.selectiveClient\` is enabled. file: ${id}`);
-          } else if (!isVite) {
-            console.warn(`The \`nuxt-client\` attribute and client components within islands are only supported with Vite. file: ${id}`);
-          }
-        }
-        if (s.hasChanged()) {
-          return {
-            code: s.toString(),
-            map: s.generateMap({ source: id, includeContent: true })
-          };
-        }
-      }
-    }
-  };
-});
-function extractAttributes(attributes, names) {
-  const extracted = {};
-  for (const name of names) {
-    if (name in attributes) {
-      extracted[name] = attributes[name];
-      delete attributes[name];
-    }
-  }
-  return extracted;
-}
-function attributeToString(attributes) {
-  return Object.entries(attributes).map(([name, value]) => value ? ` ${name}="${value}"` : ` ${name}`).join("");
-}
-function isBinding(attr) {
-  return attr.startsWith(":");
-}
-function getPropsToString(bindings) {
-  const vfor = bindings["v-for"]?.split(" in ").map((v) => v.trim());
-  if (Object.keys(bindings).length === 0) {
-    return "undefined";
-  }
-  const content = Object.entries(bindings).filter((b) => b[0] && (b[0] !== "_bind" && b[0] !== "v-for")).map(([name, value]) => isBinding(name) ? `[\`${name.slice(1)}\`]: ${value}` : `[\`${name}\`]: \`${value}\``).join(",");
-  const data = bindings._bind ? `__mergeProps(${bindings._bind}, { ${content} })` : `{ ${content} }`;
-  if (!vfor) {
-    return `[${data}]`;
-  } else {
-    return `__vforToArray(${vfor[1]}).map(${vfor[0]} => (${data}))`;
-  }
-}
-const COMPONENT_CHUNK_ID = `#build/component-chunk`;
-const COMPONENT_CHUNK_RESOLVED_ID = "\0nuxt-component-chunk";
-const ComponentsChunkPlugin = (options) => {
-  const chunkIds = /* @__PURE__ */ new Map();
-  const paths = /* @__PURE__ */ new Map();
-  return [
-    {
-      name: "nuxt:components-chunk:client",
-      apply: () => !options.dev,
-      applyToEnvironment: (environment) => environment.name === "client",
-      buildStart() {
-        for (const c of options.getComponents()) {
-          if (!c.filePath || c.mode === "server") {
-            continue;
-          }
-          chunkIds.set(c.pascalName, this.emitFile({
-            type: "chunk",
-            name: `${c.pascalName}-chunk.mjs`,
-            id: c.filePath,
-            preserveSignature: "strict"
-          }));
-        }
-      },
-      generateBundle(_, bundle) {
-        const ids = /* @__PURE__ */ new Set();
-        for (const [name, id] of chunkIds.entries()) {
-          const filename = this.getFileName(id);
-          ids.add(filename);
-          paths.set(name, filename);
-        }
-        for (const chunk of Object.values(bundle)) {
-          if (chunk.type === "chunk") {
-            if (ids.has(chunk.fileName)) {
-              chunk.isEntry = false;
-            }
-          }
-        }
-      }
-    },
-    {
-      name: "nuxt:components-chunk:server",
-      resolveId: {
-        order: "pre",
-        handler(id) {
-          if (id === COMPONENT_CHUNK_ID) {
-            return COMPONENT_CHUNK_RESOLVED_ID;
-          }
-        }
-      },
-      load(id) {
-        if (id === COMPONENT_CHUNK_RESOLVED_ID) {
-          if (options.dev) {
-            const filePaths = {};
-            for (const c of options.getComponents()) {
-              if (!c.filePath || c.mode === "server") {
-                continue;
-              }
-              filePaths[c.pascalName] = `@fs/${c.filePath}`;
-            }
-            return `export default ${genObjectFromRawEntries(Object.entries(filePaths).map(([name, path]) => [name, genString(path)]))}`;
-          }
-          return `export default ${genObjectFromRawEntries(Array.from(paths.entries()).map(([name, id2]) => [name, genString("/" + id2)]))}`;
-        }
-      }
-    }
-  ];
-};
-
 const COMPONENT_QUERY_RE = /[?&]nuxt_component=/;
 function TransformPlugin$1(nuxt, options) {
   const componentUnimport = createUnimport({
@@ -3509,32 +3300,7 @@ const componentsModule = defineNuxtModule({
       }));
       addImportsSources(lazyHydrationMacroPreset);
     }
-    if (nuxt.options.experimental.componentIslands) {
-      const selectiveClient = typeof nuxt.options.experimental.componentIslands === "object" && nuxt.options.experimental.componentIslands.selectiveClient;
-      addVitePlugin({
-        name: "nuxt-server-component-hmr",
-        handleHotUpdate(ctx) {
-          const components = getComponents();
-          const filePath = normalize(ctx.file);
-          const comp = components.find((c) => c.filePath === filePath);
-          if (comp?.mode === "server") {
-            ctx.server.ws.send({
-              event: `nuxt-server-component:${comp.pascalName}`,
-              type: "custom"
-            });
-          }
-        }
-      }, { server: false });
-      addBuildPlugin(IslandsTransformPlugin({ getComponents, selectiveClient }), { client: false });
-      if (selectiveClient && nuxt.options.builder === "@nuxt/vite-builder") {
-        addVitePlugin(() => ComponentsChunkPlugin({ dev: nuxt.options.dev, getComponents }));
-      } else {
-        addTemplate({
-          filename: "component-chunk.mjs",
-          getContents: () => `export default {}`
-        });
-      }
-    }
+    if (nuxt.options.experimental.componentIslands) ;
   }
 });
 
@@ -4157,8 +3923,18 @@ async function initNitro(nuxt) {
             }
             return targets;
           }, [])
-        ] : []
-      ]
+        ] : [],
+        // todo fix 
+        ...[
+          ...nuxt.options.modulesDir.reduce((targets, path) => {
+            const serverRendererPath = resolve(path, "vue/index.mjs");
+            if (existsSync(serverRendererPath)) {
+              targets.push(serverRendererPath);
+            }
+            return targets;
+          }, [])
+        ]
+      ],
     },
     alias: {
       // Vue 3 mocks
@@ -4194,7 +3970,7 @@ async function initNitro(nuxt) {
           // temporary fix for https://github.com/vuejs/core/issues/8351
         }
       },
-      plugins: []
+      plugins: [],
     },
     logLevel: logLevelMapReverse[nuxt.options.logLevel]
   });
@@ -4570,6 +4346,7 @@ async function initNitro(nuxt) {
         if (name === "server") {
           const memfs = compiler.outputFileSystem;
           nitro.options.virtual["#build/dist/server/server.mjs"] = () => memfs.readFileSync(join(nuxt.options.buildDir, "dist/server/server.mjs"), "utf-8");
+          nitro.options.virtual["#build/dist/server/components.islands.mjs"] = () => memfs.readFileSync(join(nuxt.options.buildDir, "dist/server/components.islands.mjs"), "utf-8");
         }
       });
       nuxt.hook(`${builder}:compiled`, () => {
@@ -6073,7 +5850,7 @@ const rootComponentTemplate = {
   filename: "root-component.mjs",
   // TODO: fix upstream in vite - this ensures that vite generates a module graph for islands
   // but should not be necessary (and has a warmup performance cost). See https://github.com/nuxt/nuxt/pull/24584.
-  getContents: (ctx) => (ctx.nuxt.options.dev ? "import '#build/components.islands.mjs';\n" : "") + genExport(ctx.app.rootComponent, ["default"])
+  getContents: (ctx) => genExport(ctx.app.rootComponent, ["default"])
 };
 const errorComponentTemplate = {
   filename: "error-component.mjs",
